bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	36	1	add
2	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	36	1	add
3	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s  [CE]  ')'  expected  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s	  	non-compiled	[CE]  ')'  expected	36	None	add
4	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  nu  [CE]  ')'  expected  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  nu  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  nu	  	non-compiled	[CE]  ')'  expected	36	None	add
5	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se  [CE]  ')'  expected  [FE]          IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se	  	non-compiled	[CE]  ')'  expected	36	None	add
6	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(  [CE]  illegal  start  of  expression  [FE]            IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
7	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notSeparator);  [CE]  cannot  find  symbol  notSeparator  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notSeparator);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notSeparator);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iBeforeParser);    	non-compiled	[CE]  cannot  find  symbol  notSeparator	20	None	replace
8	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.getParser());  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.getParser());	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iAfterParser);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	64	None	replace
9	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFunction);  [CE]  cannot  find  symbol  notFunction  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFunction);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFunction);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iAfterParser);    	non-compiled	[CE]  cannot  find  symbol  notFunction	64	None	replace
10	[BUG]  [BUGGY]  parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	39	None	replace
11	[BUG]  [BUGGY]  parent  ==  null  &&  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent  ==  null  &&  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent  ==  null  &&  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	39	None	replace
12	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  true);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  true);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  true);	  TextUtilities.appendSuffix(text,    false);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
13	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  false,  text);  [CE]  illegal  start  of  type  [FE]                    IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  false,  text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  false,  text);	  TextUtilities.appendSuffix(text,    false);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
14	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  false,  null);  [CE]  illegal  start  of  type  [FE]                      IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  false,  null);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  false,  null);	  TextUtilities.appendSuffix(text,    false);    	non-compiled	[CE]  illegal  start  of  type	71	None	replace
15	[BUG]  [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(sep.getPrinter(),  f.getParser());	  sep    =    sep.finish(ep.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	56	None	replace
16	[BUG]  [BUGGY]  Sep  <  Object>  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  <  Object>  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  <  Object>  sep  =  f.finish(sep.getPrinter(),  f.getParser());	  Sep    <    Object>    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	68	None	replace
17	[BUG]  [BUGGY]  Sep  <  Object>  sep  =  parser.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  <  Object>  sep  =  parser.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  <  Object>  sep  =  parser.finish(f.getPrinter(),  f.getParser());	  Sep    <    Object>    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	68	None	replace
18	[BUG]  [BUGGY]  Sep  <  Object>  sep  =  f.finish(f.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  <  Object>  sep  =  f.finish(f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  <  Object>  sep  =  f.finish(f.getPrinter(),  sep.getParser());	  Sep    <    Object>    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	68	None	replace
19	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  sep);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  sep);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  sep);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	75	None	replace
20	[BUG]  [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	75	None	replace
21	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	75	None	replace
22	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  notPrinter);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	75	None	replace
23	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  <  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.length()  <  0)  {	  if(text    ==    null    ||    text.length()    >=    0)    {    	compilable	  [FE]  IllegalArgumentException  	18	1	replace
24	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  <  0)  {  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  <  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.length()  <  0)  {	  if(text    ==    null    ||    text.length()    >=    0)    {    	compilable	  [FE]  IllegalArgumentException  	18	1	replace
25	[BUG]  [BUGGY]  sep  =  f.finish(sep,  f.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(sep,  f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(sep,  f.getPrinter(),  sep.getParser());	  sep    =    sep.finish(sep,    f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol	72	None	replace
26	[BUG]  [BUGGY]  sep  =  sep.finish(sep,  f.getPrinter(),  f.getParser());  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(sep,  f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(sep,  f.getPrinter(),  f.getParser());	  sep    =    sep.finish(sep,    f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	72	None	replace
27	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]          IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "- "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.equals( "- "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ".       "))    {    	compilable	  [FE]  IllegalArgumentException  	8	1	replace
28	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals( "- "))  {  [FE]  IllegalArgumentException  [FE]          IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "- "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.equals( "- "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ".       "))    {    	compilable	  [FE]  IllegalArgumentException  	8	1	replace
29	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	78	None	add
30	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  ==  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  ==  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text  ==  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	78	None	add
31	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  If(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  ';'  expected  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  If(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    If(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  ';'  expected	78	None	add
32	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  >=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  >=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text  >=  null)  {  for(int  i  =  0,  len  =  text.length();  i  <  len;  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	78	None	add
33	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  illegal  start  of  expression  [FE]    StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  	non-compiled	[CE]  illegal  start  of  expression	80	None	add
34	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  illegal  start  of  expression  [FE]      StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  	non-compiled	[CE]  illegal  start  of  expression	80	None	add
35	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  ';'  expected  [FE]        StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  	non-compiled	[CE]  ';'  expected	80	None	add
36	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  illegal  start  of  expression  [FE]          StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  	non-compiled	[CE]  illegal  start  of  expression	80	None	add
37	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  notPrinter.getParser());	  int    sep    =    f.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	12	None	replace
38	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notParser.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notParser.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  notParser.getParser());	  int    sep    =    f.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	12	None	replace
39	[BUG]  [BUGGY]  int  sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());	  int    sep    =    f.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	12	None	replace
40	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]            IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "n "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.equals( "n "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ",       "))    {    	compilable	  [FE]  IllegalArgumentException  	9	1	replace
41	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals( "n "))  {  [FE]  IllegalArgumentException  [FE]            IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "n "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.equals( "n "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ",       "))    {    	compilable	  [FE]  IllegalArgumentException  	9	1	replace
42	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "] "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.equals( "] "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ",       "))    {    	compilable	  [FE]  IllegalArgumentException  	9	1	replace
43	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals( "] "))  {  [FE]  IllegalArgumentException  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "] "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.equals( "] "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text    ==    null    ||    text.equals(   ",       "))    {    	compilable	  [FE]  IllegalArgumentException  	9	1	replace
44	[BUG]  [BUGGY]  sep  =  f.finish(sep.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(sep.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(sep.getPrinter(),  sep.getParser());	  sep    =    sep.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
45	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  size);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  size);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  size);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	67	None	replace
46	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	67	None	replace
47	[BUG]  [BUGGY]  sep  =  s.finish(sep.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  s.finish(sep.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  s.finish(sep.getPrinter(),  f.getParser());	  sep    =    s.finish(sep.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol	35	None	replace
48	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  f.getParser(),  notPrinter);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	32	None	replace
49	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  size);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  size);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser(),  size);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	32	None	replace
50	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  size);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  size);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  f.getParser(),  size);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	32	None	replace
51	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text!=  null  ||  text.equals( "   "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text!=    null    ||    text.equals(   "       "))    {    	compilable	  [FE]  IllegalArgumentException  	10	6	replace
52	[BUG]  [BUGGY]  if(text!=  null  ||  text.equals( "   "))  {  [FE]  IllegalArgumentException  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=  null  ||  text.equals( "   "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    if(text!=    null    ||    text.equals(   "       "))    {    	compilable	  [FE]  IllegalArgumentException  	10	6	replace
53	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  1),  notPrinter);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  1),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  +  1),  notPrinter);	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	6	None	replace
54	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter  +  1));  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter  +  1));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter  +  1));	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	6	None	replace
55	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  1,  notPrinter));  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  1,  notPrinter));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  +  1,  notPrinter));	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	6	None	replace
56	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  1));  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  1));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  -  1));	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	6	None	replace
57	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()!=  0)  {  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    if(text!=  null  ||  text.length()!=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
58	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text  ==  null  ||  text.length()!=  0)  {  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text  ==  null  ||  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    if(text  ==  null  ||  text.length()!=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
59	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()  ==  0)  {  [CE]  illegal  start  of  expression  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    if(text!=  null  ||  text.length()  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
60	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()  >=  0)  {  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text!=  null  ||  text.length()  >=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    if(text!=  null  ||  text.length()  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
61	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text  ==  null  ||  text.length()  >=  0)  {  [CE]  illegal  start  of  expression  [FE]            IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  if(text  ==  null  ||  text.length()  >=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    if(text  ==  null  ||  text.length()  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
62	[BUG]  [BUGGY]  appendSuffix(text,  false);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  false);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  false);	  appendSuffix(text);    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
63	[BUG]  [BUGGY]  If(text  ==  null  ||  text.equals( "   "))  {  [CE]  [FE]        IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  If(text  ==  null  ||  text.equals( "   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	If(text  ==  null  ||  text.equals( "   "))  {	  if(text    ==    null    ||    text.equals(       "       "))    {    If(text    ==    null    ||    text.equals(   "       "))    {    	non-compiled	[CE]  	63	None	replace
64	[BUG]  [BUGGY]  AppendSuffix(text,  false);  [CE]  illegal  start  of  type  [FE]                    IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  AppendSuffix(text,  false);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	AppendSuffix(text,  false);	  appendSuffix(text,    true);    	non-compiled	[CE]  illegal  start  of  type	26	None	replace
65	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "* "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text!=  null  ||  text.equals( "* "))  {	  if(text    ==    null    ||    text.equals(   "*   "))    {    	compilable	  [FE]  IllegalArgumentException  	58	6	replace
66	[BUG]  [BUGGY]  if(text!=  null  ||  text.equals( "* "))  {  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "* "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=  null  ||  text.equals( "* "))  {	  if(text    ==    null    ||    text.equals(   "*   "))    {    	compilable	  [FE]  IllegalArgumentException  	58	6	replace
67	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.startsWith( "* "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.startsWith( "* "))  {	  if(text    ==    null    ||    text.equals(   "*   "))    {    	compilable	  [FE]  IllegalArgumentException  	58	1	replace
68	[BUG]  [BUGGY]  if(text  ==  null  ||  text.startsWith( "* "))  {  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.startsWith( "* "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.startsWith( "* "))  {	  if(text    ==    null    ||    text.equals(   "*   "))    {    	compilable	  [FE]  IllegalArgumentException  	58	1	replace
69	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text!=  null  ||  text.length()  ==  0)  {  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text!=  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()    ==    0)    {    if(text!=  null  ||  text.length()  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	15	None	add
70	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text  ==  null  ||  text.length()  ==  0)  {  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text  ==  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()    ==    0)    {    if(text  ==  null  ||  text.length()  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	15	None	add
71	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text  >=  null  ||  text.length()  ==  0)  {  [CE]  illegal  start  of  expression  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  if(text  >=  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()    ==    0)    {    if(text  >=  null  ||  text.length()  ==  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	15	None	add
72	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  If(text!=  null  ||  text.length()  ==  0)  {  [CE]  ';'  expected  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()  ==  0)  {  If(text!=  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()    ==    0)    {    If(text!=  null  ||  text.length()  ==  0)  {	  	non-compiled	[CE]  ';'  expected	15	None	add
73	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	21	None	replace
74	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	21	None	replace
75	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  null);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  null);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  null);	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
76	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  text.length());  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  text.length());  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  text.length());	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
77	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  notPrinter.getParser());	  int    sep    =    sep.finish(f.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	11	None	replace
78	[BUG]  [BUGGY]  int  sep  =  f.finish(sep.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(sep.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(sep.getPrinter(),  notPrinter.getParser());	  int    sep    =    sep.finish(f.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	11	None	replace
79	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( "*   "))  {  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( "*   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "*   "))    {    if(text  ==  null  ||  text.equals( "*   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	57	None	add
80	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( ".*   "))  {  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( ".*   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "*   "))    {    if(text  ==  null  ||  text.equals( ".*   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	57	None	add
81	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text!=  null  ||  text.equals( "*   "))  {  [CE]  illegal  start  of  expression  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text!=  null  ||  text.equals( "*   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "*   "))    {    if(text!=  null  ||  text.equals( "*   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	57	None	add
82	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( ",*   "))  {  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  if(text  ==  null  ||  text.equals( ",*   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "*   "))    {    if(text  ==  null  ||  text.equals( ",*   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	57	None	add
83	[BUG]  [BUGGY]  parent!=  null  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent!=  null  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent!=  null  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  parent!=    null    &&    notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	46	None	replace
84	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  notParser);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  notParser);	  sep    =    sep.finish(elementPairs.subList(1,    size),    notPrinter,    notParser);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	65	None	replace
85	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  iBeforeParser);  [CE]  cannot  find  symbol  iBeforeParser  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  iBeforeParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter,  notParser,  iBeforeParser);	  sep    =    sep.finish(elementPairs.subList(1,    size),    notPrinter,    notParser);    	non-compiled	[CE]  cannot  find  symbol  iBeforeParser	65	None	replace
86	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	38	1	add
87	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	38	1	add
88	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s  [CE]  ')'  expected  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(s	  	non-compiled	[CE]  ')'  expected	38	None	add
89	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se  [CE]  ')'  expected  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(se	  	non-compiled	[CE]  ')'  expected	38	None	add
90	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  nu  [CE]  ')'  expected  [FE]          IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  nu  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  nu	  	non-compiled	[CE]  ')'  expected	38	None	add
91	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(  [CE]  illegal  start  of  expression  [FE]            IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
92	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  notPrinter.getParser());	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
93	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  notParser.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  notParser.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  notParser.getParser());	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
94	[BUG]  [BUGGY]  int  sep  =  f.finish(parser.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(parser.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(parser.getPrinter(),  sep.getParser());	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
95	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  size,  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  size,  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  size,  f.getParser());	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
96	[BUG]  [BUGGY]  If(text  ==  null  ||  text.length()!=  0)  {  [CE]  ';'  expected  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  If(text  ==  null  ||  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	If(text  ==  null  ||  text.length()!=  0)  {	  if(text    ==    null    ||    text.length()!=    0)    {    If(text    ==    null    ||    text.length()!=    0)    {    	non-compiled	[CE]  ';'  expected	54	None	replace
97	[BUG]  [BUGGY]  If(text  ==  null  ||  text.length()  ==  0)  {  [CE]  ';'  expected  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  If(text  ==  null  ||  text.length()  ==  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	If(text  ==  null  ||  text.length()  ==  0)  {	  if(text    ==    null    ||    text.length()!=    0)    {    If(text    ==    null    ||    text.length()!=    0)    {    	non-compiled	[CE]  ';'  expected	54	None	replace
98	[BUG]  [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  illegal  start  of  expression	61	None	replace
99	[BUG]  [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  illegal  start  of  expression	61	None	replace
100	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
101	[BUG]  [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
102	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  iAfterParser);  [CE]  cannot  find  symbol  iAfterParser  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  iAfterParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  iAfterParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    notParser);    	non-compiled	[CE]  cannot  find  symbol  iAfterParser	19	None	replace
103	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser,  notParser);  [CE]  ')'  expected  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    notParser);    	non-compiled	[CE]  ')'  expected	19	None	replace
104	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size),  notPrinter,  notParser,  notParser);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size),  notPrinter,  notParser,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(0,  size),  notPrinter,  notParser,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    notParser);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	19	None	replace
105	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "0x "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.equals( "0x "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
106	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals( "0x "))  {  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "0x "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.equals( "0x "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
107	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text!=  null  ||  text.equals( "0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	6	replace
108	[BUG]  [BUGGY]  if(text!=  null  ||  text.equals( "0 "))  {  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.equals( "0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=  null  ||  text.equals( "0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	6	replace
109	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter),  notParser);  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter),  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter),  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter);    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	5	None	replace
110	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size  -  1,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size  -  1,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size  -  1,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size    -    1,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	22	None	replace
111	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  2,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  2,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  -  2,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size    -    1,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	22	None	replace
112	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( "0   "))  {  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( "0   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "0   "))    {    if(text  ==  null  ||  text.equals( "0   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
113	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( ".0   "))  {  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( ".0   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "0   "))    {    if(text  ==  null  ||  text.equals( ".0   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
114	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( ",0   "))  {  [CE]  illegal  start  of  expression  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text  ==  null  ||  text.equals( ",0   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "0   "))    {    if(text  ==  null  ||  text.equals( ",0   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
115	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text!=  null  ||  text.equals( "0   "))  {  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  if(text!=  null  ||  text.equals( "0   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "0   "))    {    if(text!=  null  ||  text.equals( "0   "))  {	  	non-compiled	[CE]  illegal  start  of  expression	13	None	add
116	[BUG]  [BUGGY]  parser  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  parser  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parser  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parser  =  sep.finish(f.getPrinter(),  f.getParser());	  aught    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol  parser	73	None	replace
117	[BUG]  [BUGGY]  f  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  incompatible  types  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  f  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	f  =  sep.finish(f.getPrinter(),  f.getParser());	  aught    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  incompatible  types	73	None	replace
118	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	76	None	add
119	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text  ==  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	76	None	add
120	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  ';'  expected  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    If(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  ';'  expected	76	None	add
121	[BUG]  [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    if(text  >=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  	non-compiled	[CE]  illegal  start  of  expression	76	None	add
122	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	60	1	add
123	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	60	1	add
124	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	non-compiled	[CE]  illegal  start  of  expression	60	None	add
125	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  Sep  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  Sep  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    Sep  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	non-compiled	[CE]  cannot  find  symbol	60	None	add
126	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter()  [CE]  ')'  expected  [FE]          IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter()  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter()	  	non-compiled	[CE]  ')'  expected	60	None	add
127	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.get  [CE]  ')'  expected  [FE]            IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.get  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.get	  	non-compiled	[CE]  ')'  expected	60	None	add
128	[BUG]  [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  Sep  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  =  sep.finish(f.getPrinter(),  f.getParser());  Sep  =  sep.finish(f.getPrinter(),  f.getParser());	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    Sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol  Sep	3	None	replace
129	[BUG]  [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  Sep  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  =  sep.finish(f.getPrinter(),  f.getParser());	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    Sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol  Sep	3	None	replace
130	[BUG]  [BUGGY]  sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(elementPairs.getPrinter(),  sep.getParser());	  sep    =    sep.finish(elementPairs.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
131	[BUG]  [BUGGY]  sep  =  parser.finish(elementPairs.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  parser.finish(elementPairs.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  parser.finish(elementPairs.getPrinter(),  f.getParser());	  sep    =    sep.finish(elementPairs.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
132	[BUG]  [BUGGY]  sep  =  elementPairs.finish(f.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  elementPairs.finish(f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  elementPairs.finish(f.getPrinter(),  sep.getParser());	  sep    =    sep.finish(elementPairs.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
133	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  notPrinter,  notParser);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	43	None	replace
134	[BUG]  [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [CE]  cannot  find  symbol  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getParser(),  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(sep.getPrinter(),  f.getParser(),  notPrinter,  notParser);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  cannot  find  symbol	43	None	replace
135	[BUG]  [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(elementPairs.getPrinter(),  notPrinter.getParser());	  int    sep    =    sep.finish(sep.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	28	None	replace
136	[BUG]  [BUGGY]  int  sep  =  s.finish(sep.getPrinter(),  notPrinter.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(sep.getPrinter(),  notPrinter.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(sep.getPrinter(),  notPrinter.getParser());	  int    sep    =    sep.finish(sep.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	28	None	replace
137	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()  >=  0)  {  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()  >=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.length()    >=    0)    {    if(text  ==  null  ||  text.length()  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
138	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()!=  0)  {  [CE]  illegal  start  of  expression  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.length()    >=    0)    {    if(text  ==  null  ||  text.length()!=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
139	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()  >>  0)  {  [CE]  illegal  start  of  expression  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text  ==  null  ||  text.length()  >>  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.length()    >=    0)    {    if(text  ==  null  ||  text.length()  >>  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
140	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text!=  null  ||  text.length()  >=  0)  {  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  if(text!=  null  ||  text.length()  >=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.length()    >=    0)    {    if(text!=  null  ||  text.length()  >=  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
141	[BUG]  [BUGGY]  parent  <?>  sep  =  parent.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent  <?>  sep  =  parent.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent  <?>  sep  =  parent.finish(f.getPrinter(),  f.getParser());	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  cannot  find  symbol	66	None	replace
142	[BUG]  [BUGGY]  parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  [CE]  not  a  statement  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent!=  null)  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	66	None	replace
143	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter));  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size,  notPrinter));	  sep    =    sep.finish(elementPairs.subList(1,    size));    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	59	None	replace
144	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size),  notPrinter);	  sep    =    sep.finish(elementPairs.subList(1,    size));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	59	None	replace
145	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size));  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(3,  size));	  sep    =    sep.finish(elementPairs.subList(1,    size));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	59	None	replace
146	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
147	[BUG]  [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
148	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
149	[BUG]  [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
150	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
151	[BUG]  [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  ComparisonFailure  	2	4	replace
152	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  not  a  statement  [FE]    StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  not  a  statement	81	None	replace
153	[BUG]  [BUGGY]  FormatterBuilder  <  String>emptyAttributes()  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  ';'  expected  [FE]      StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>emptyAttributes()  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>emptyAttributes()  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  ';'  expected	81	None	replace
154	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(text);  }  [CE]  not  a  statement  [FE]        StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(text);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  not  a  statement	81	None	replace
155	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  iMinPrintedDigits);  }  [CE]  not  a  statement  [FE]          StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  iMinPrintedDigits);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  iMinPrintedDigits);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  not  a  statement	81	None	replace
156	[BUG]  [BUGGY]  int  sep  =  s.finish(elementPairs.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(elementPairs.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(elementPairs.getPrinter(),  sep.getParser());	  int    sep    =    sep.finish(elementPairs.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	27	None	replace
157	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  sep.getParser());	  int    sep    =    sep.finish(elementPairs.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	27	None	replace
158	[BUG]  [BUGGY]  int  sep  =  s.finish(elementPairs.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(elementPairs.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(elementPairs.getPrinter(),  f.getParser());	  int    sep    =    s.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	62	None	replace
159	[BUG]  [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getSeparator());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(sep.getPrinter(),  f.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(sep.getPrinter(),  f.getSeparator());	  sep    =    sep.finish(f.getPrinter(),    f.getSeparator());    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
160	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  text);  [CE]  illegal  start  of  type  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  text);	  TextUtilities.appendSuffix(text);    	non-compiled	[CE]  illegal  start  of  type	69	None	replace
161	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  iPluralText);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  iPluralText);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  iPluralText);	  TextUtilities.appendSuffix(text);    	non-compiled	[CE]  illegal  start  of  type	69	None	replace
162	[BUG]  [BUGGY]  AppendUtilities.appendSuffix(text,  this);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  AppendUtilities.appendSuffix(text,  this);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	AppendUtilities.appendSuffix(text,  this);	  TextUtilities.appendSuffix(text,    this);    	non-compiled	[CE]  illegal  start  of  type	70	None	replace
163	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  0);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  0);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  0);	  TextUtilities.appendSuffix(text,    this);    	non-compiled	[CE]  illegal  start  of  type	70	None	replace
164	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  not  a  statement  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	77	None	replace
165	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_SECOND>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  not  a  statement  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_SECOND>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_SECOND>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	77	None	replace
166	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(new  SimpleAffix(text));  }  [CE]  not  a  statement  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  AppendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	77	None	replace
167	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  --i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  not  a  statement  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  --i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  --i)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	77	None	replace
168	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }  [CE]  illegal  start  of  type  [FE]                    IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  illegal  start  of  type	82	None	replace
169	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }  [CE]  not  a  statement  [FE]                      IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text[i]);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  not  a  statement	82	None	replace
170	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }  [CE]  illegal  start  of  type  [FE]                        IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  illegal  start  of  type	82	None	replace
171	[BUG]  [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }  [CE]  not  a  statement  [FE]                          IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  null);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  not  a  statement	82	None	replace
172	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_MODULE>  builder  =  new  SimpleAffix(text);  [CE]  illegal  start  of  type  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_MODULE>  builder  =  new  SimpleAffix(text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_MODULE>  builder  =  new  SimpleAffix(text);	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
173	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_SECOND>  template  =  new  SimpleAffix(text);  [CE]  illegal  start  of  type  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_SECOND>  template  =  new  SimpleAffix(text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_SECOND>  template  =  new  SimpleAffix(text);	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
174	[BUG]  [BUGGY]  FormatterBuilder  <  String>  this  =  new  SimpleAffix(text);  [CE]  not  a  statement  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>  this  =  new  SimpleAffix(text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>  this  =  new  SimpleAffix(text);	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	79	None	replace
175	[BUG]  [BUGGY]  FormatterBuilder  <  String>  this  =  new  SimpleAffix(text.length());  [CE]  not  a  statement  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  String>  this  =  new  SimpleAffix(text.length());  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  String>  this  =  new  SimpleAffix(text.length());	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  not  a  statement	79	None	replace
176	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(elementPairs.getPrinter(),  f.getParser());	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
177	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notParser);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  notParser);	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
178	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  f.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(f.getPrinter(),  f.getSeparator());	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
179	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());	  	compilable	  [FE]  IllegalArgumentException  	1	1	add
180	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());	  	compilable	  [FE]  IllegalArgumentException  	1	1	add
181	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  Sep  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  Sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    Sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());	  	non-compiled	[CE]  cannot  find  symbol  Sep	1	None	add
182	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	1	1	add
183	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  IllegalArgumentException  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	  	compilable	  [FE]  IllegalArgumentException  	1	1	add
184	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  notParser.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  notParser.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  notParser.getParser());	  int    sep    =    s.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	55	None	replace
185	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  sep.getParser(),  notPrinter);	  int    sep    =    s.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	55	None	replace
186	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser));  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size,  notPrinter,  notParser));	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter));    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
187	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter));  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(0,  size,  notPrinter));	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter));    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
188	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter));  [CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;  [FE]                        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter));	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter));    	non-compiled	[CE]  method  subList  in  interface  List<E>  cannot  be  applied  to  given  types;	4	None	replace
189	[BUG]  [BUGGY]  int  sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());	  int    sep    =    f.finish(sep.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	31	None	replace
190	[BUG]  [BUGGY]  int  sep  =  f.finish(separator.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(separator.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(separator.getPrinter(),  f.getParser());	  int    sep    =    f.finish(sep.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	31	None	replace
191	[BUG]  [BUGGY]  appendSuffix(text,  null,  null);  [CE]  illegal  start  of  type  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  null,  null);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  null,  null);	  appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
192	[BUG]  [BUGGY]  appendSuffix(text,  null,  text.length());  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  null,  text.length());  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  null,  text.length());	  appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
193	[BUG]  [BUGGY]  appendSuffix(text,  null,  false);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  null,  false);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  null,  false);	  appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
194	[BUG]  [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  notParser);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(f.getPrinter(),  notParser);	  int    sep    =    sep.finish(f.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	11	None	replace
195	[BUG]  [BUGGY]  FormatterBuilder.appendSuffix(new  SimpleAffix(text));  [CE]  illegal  start  of  type  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder.appendSuffix(new  SimpleAffix(text));  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder.appendSuffix(new  SimpleAffix(text));	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
196	[BUG]  [BUGGY]  FormatterBuilder.appendSuffix(text);  [CE]  illegal  start  of  type  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder.appendSuffix(text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder.appendSuffix(text);	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
197	[BUG]  [BUGGY]  Iterator  <  String>  it  =  text.iterator();  [CE]  illegal  start  of  type  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  Iterator  <  String>  it  =  text.iterator();  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	Iterator  <  String>  it  =  text.iterator();	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
198	[BUG]  [BUGGY]  MutableFormat.appendSuffix(new  SimpleAffix(text));  [CE]  illegal  start  of  type  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  MutableFormat.appendSuffix(new  SimpleAffix(text));  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	MutableFormat.appendSuffix(new  SimpleAffix(text));	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
199	[BUG]  [BUGGY]  Sept  <  Object>  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sept  <  Object>  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sept  <  Object>  sep  =  sep.finish(f.getPrinter(),  f.getParser());	  Sep    <    Object>    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	68	None	replace
200	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if  [CE]  '('  expected  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if	  	non-compiled	[CE]  '('  expected	38	None	add
201	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar  [CE]  ')'  expected  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar	  	non-compiled	[CE]  ')'  expected	38	None	add
202	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  beforeParser);  [CE]  cannot  find  symbol  beforeParser  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  beforeParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  beforeParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iAfterParser);    	non-compiled	[CE]  cannot  find  symbol  beforeParser	64	None	replace
203	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notAfterParser);  [CE]  cannot  find  symbol  notAfterParser  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notAfterParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notAfterParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iAfterParser);    	non-compiled	[CE]  cannot  find  symbol  notAfterParser	64	None	replace
204	[BUG]  [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getSeparator());  [CE]  cannot  find  symbol  Sep  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  =  sep.finish(f.getPrinter(),  f.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  =  sep.finish(f.getPrinter(),  f.getSeparator());	  sep    =    sep.finish(f.getPrinter(),    f.getSeparator());    	non-compiled	[CE]  cannot  find  symbol  Sep	41	None	replace
205	[BUG]  [BUGGY]  Iterator  <  String>  it  =  iSingularText.iterator();  [CE]  illegal  start  of  type  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  Iterator  <  String>  it  =  iSingularText.iterator();  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	Iterator  <  String>  it  =  iSingularText.iterator();	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	77	None	replace
206	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());	  	compilable	  [FE]  IllegalArgumentException  	60	1	add
207	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    sep  =  sep.finish(f.getPrinter(),  f.getParser());	  	compilable	  [FE]  IllegalArgumentException  	60	1	add
208	[BUG]  [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getSeparator());	  int    sep    =    sep.finish(elementPairs.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	27	None	replace
209	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(3,  size,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	21	None	replace
210	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if  [CE]  '('  expected  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if	  	non-compiled	[CE]  '('  expected	36	None	add
211	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar  [CE]  ')'  expected  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getPar	  	non-compiled	[CE]  ')'  expected	36	None	add
212	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  sep.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  sep.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  sep.getSeparator());	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
213	[BUG]  [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  illegal  start  of  expression  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  illegal  start  of  expression	61	None	replace
214	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  sep);	  int    sep    =    s.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	62	None	replace
215	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  f.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  f.getSeparator());	  int    sep    =    s.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	62	None	replace
216	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size),  notPrinter,  notParser);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size),  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(3,  size),  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(1,    size),    notPrinter,    notParser);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	65	None	replace
217	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  sep.getSeparator());	  int    sep    =    s.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	55	None	replace
218	[BUG]  [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getPrefix());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  s.finish(f.getPrinter(),  sep.getPrefix());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  s.finish(f.getPrinter(),  sep.getPrefix());	  int    sep    =    s.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	55	None	replace
219	[BUG]  [BUGGY]  sep  =  sep.finish(f,  f.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f,  f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f,  f.getPrinter(),  sep.getParser());	  sep    =    sep.finish(sep,    f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol	72	None	replace
220	[BUG]  [BUGGY]  safeSep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  safeSep  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  safeSep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	safeSep  =  sep.finish(f.getPrinter(),  f.getParser());	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  cannot  find  symbol  safeSep	66	None	replace
221	[BUG]  [BUGGY]  safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  ';'  expected  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  ';'  expected	66	None	replace
222	[BUG]  [BUGGY]  safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  ';'  expected  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	safeSep(sep)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  ';'  expected	66	None	replace
223	[BUG]  [BUGGY]  safeNameMap.put(f.getPrinter(),  sep);  [CE]  cannot  find  symbol  safeNameMap  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  safeNameMap.put(f.getPrinter(),  sep);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	safeNameMap.put(f.getPrinter(),  sep);	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    >=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  cannot  find  symbol  safeNameMap	66	None	replace
224	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  beforeParser);  [CE]  cannot  find  symbol  beforeParser  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  beforeParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  beforeParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    notParser);    	non-compiled	[CE]  cannot  find  symbol  beforeParser	19	None	replace
225	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size  -  1,  notPrinter,  notParser);  [CE]  ')'  expected  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(3,  size  -  1,  notPrinter,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(3,  size  -  1,  notPrinter,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size    -    1,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	22	None	replace
226	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  size);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  size);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  size);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	67	None	replace
227	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [CE]  illegal  start  of  type  [FE]                    IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  illegal  start  of  type	82	None	replace
228	[BUG]  [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter());  sep  =  sep.finish(f.getParser(),  f.getParser());  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter());  sep  =  sep.finish(f.getParser(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                sep        =        sep.finish(f.getPrinter(),        f.getParser());        sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep  =  sep.finish(f.getPrinter());  sep  =  sep.finish(f.getParser(),  f.getParser());	  	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	1	None	add
229	[BUG]  [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  If(text!=  null  ||  text.length()!=  0)  {  [CE]  ';'  expected  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  ||  text.length()!=  0)  {  If(text!=  null  ||  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=    null    ||    text.length()!=    0)    {    If(text!=  null  ||  text.length()!=  0)  {	  	non-compiled	[CE]  ';'  expected	83	None	add
230	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notLast);  [CE]  cannot  find  symbol  notLast  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notLast);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notLast);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iBeforeParser);    	non-compiled	[CE]  cannot  find  symbol  notLast	20	None	replace
231	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notToken);  [CE]  cannot  find  symbol  notToken  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notToken);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notToken);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iBeforeParser);    	non-compiled	[CE]  cannot  find  symbol  notToken	20	None	replace
232	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  If(text  ==  null  ||  text.length()  >=  0)  {  [CE]  ';'  expected  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  >=  0)  {  If(text  ==  null  ||  text.length()  >=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.length()    >=    0)    {    If(text  ==  null  ||  text.length()  >=  0)  {	  	non-compiled	[CE]  ';'  expected	17	None	add
233	[BUG]  [BUGGY]  appendSuffix(text,  null,  0);  [CE]  illegal  start  of  type  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  null,  0);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  null,  0);	  appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
234	[BUG]  [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  size,  notPrinter);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	32	None	replace
235	[BUG]  [BUGGY]  Sep  aught  =  sep.finish(f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  aught  =  sep.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  aught  =  sep.finish(f.getPrinter(),  f.getParser());	  aught    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	73	None	replace
236	[BUG]  [BUGGY]  Iterator  <  String>  it  =  iSingularText.entrySet().iterator();  [CE]  illegal  start  of  type  [FE]    StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  Iterator  <  String>  it  =  iSingularText.entrySet().iterator();  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	Iterator  <  String>  it  =  iSingularText.entrySet().iterator();	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  illegal  start  of  type	81	None	replace
237	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  2),  notPrinter);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  +  2),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  +  2),  notPrinter);	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	6	None	replace
238	[BUG]  [BUGGY]  float  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  float  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	float  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
239	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(f.getPrinter(),  sep.getParser());	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
240	[BUG]  [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  sep);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  notPrinter.finish(f.getPrinter(),  sep);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  notPrinter.finish(f.getPrinter(),  sep);	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
241	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  iMinPrintedDigits);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  iMinPrintedDigits);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  iMinPrintedDigits);	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
242	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  0);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  0);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  0);	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
243	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  If(text  ==  null  ||  text.equals( "*   "))  {  [CE]  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "*   "))  {  If(text  ==  null  ||  text.equals( "*   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "*   "))    {    If(text  ==  null  ||  text.equals( "*   "))  {	  	non-compiled	[CE]  	57	None	add
244	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  If(text  ==  null  ||  text.equals(   "0   "))  {  [CE]  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals(   "0   "))  {  If(text  ==  null  ||  text.equals(   "0   "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text    ==    null    ||    text.equals(   "0   "))    {    If(text  ==  null  ||  text.equals(   "0   "))  {	  	non-compiled	[CE]  	13	None	add
245	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  notPrinter);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  null,  notPrinter);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	43	None	replace
246	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  sep.getSeparator());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  sep.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  sep.getSeparator());	  int    sep    =    f.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	12	None	replace
247	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "0.0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.equals( "0.0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
248	[BUG]  [BUGGY]  if(text  ==  null  ||  text.equals( "0.0 "))  {  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.equals( "0.0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.equals( "0.0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
249	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.startsWith( "0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.startsWith( "0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
250	[BUG]  [BUGGY]  if(text  ==  null  ||  text.startsWith( "0 "))  {  [FE]  IllegalArgumentException  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.startsWith( "0 "))  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.startsWith( "0 "))  {	  if(text    ==    null    ||    text.equals(   "0   "))    {    	compilable	  [FE]  IllegalArgumentException  	14	1	replace
251	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  &&  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text!=  null  &&  text.length()!=  0)  {	  if(text!=    null    ||    text.length()!=    0)    {    	compilable	  [FE]  IllegalArgumentException  	84	6	replace
252	[BUG]  [BUGGY]  if(text!=  null  &&  text.length()!=  0)  {  [FE]  IllegalArgumentException  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text!=  null  &&  text.length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text!=  null  &&  text.length()!=  0)  {	  if(text!=    null    ||    text.length()!=    0)    {    	compilable	  [FE]  IllegalArgumentException  	84	6	replace
253	[BUG]  [BUGGY]  }  else  if(notPrinter  &&  notParser)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  cannot  find  symbol  sep  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  }  else  if(notPrinter  &&  notParser)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	}  else  if(notPrinter  &&  notParser)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    If(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  cannot  find  symbol  sep	40	None	replace
254	[BUG]  [BUGGY]  }  else  if(notPrinter)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  cannot  find  symbol  sep  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  }  else  if(notPrinter)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	}  else  if(notPrinter)  {  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    If(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  cannot  find  symbol  sep	40	None	replace
255	[BUG]  [BUGGY]  [Delete]  [CE]  illegal  start  of  expression  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  [Delete]  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	[Delete]	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    If(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  illegal  start  of  expression	40	None	replace
256	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
257	[BUG]  [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  &&  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
258	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
259	[BUG]  [BUGGY]  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
260	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
261	[BUG]  [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [FE]  ComparisonFailure  [FE]        IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    if(notPrinter)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	compilable	  [FE]  ComparisonFailure  	61	4	replace
262	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  notAfterParser);  [CE]  cannot  find  symbol  notAfterParser  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  notAfterParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notParser,  notAfterParser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    notParser);    	non-compiled	[CE]  cannot  find  symbol  notAfterParser	19	None	replace
263	[BUG]  [BUGGY]  char  sep  =  s.finish(f.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  char  sep  =  s.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	char  sep  =  s.finish(f.getPrinter(),  f.getParser());	  int    sep    =    s.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	62	None	replace
264	[BUG]  [BUGGY]  sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());	  sep    =    sep.finish(sep,    f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	72	None	replace
265	[BUG]  [BUGGY]  [FE]  IllegalStateException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  else  {  throw  new  IllegalStateException( " ");  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	add	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  else  {  throw  new  IllegalStateException( " ");  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  IllegalStateException  	2	5	replace
266	[BUG]  [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  else  {  throw  new  IllegalStateException( " ");  }  [FE]  IllegalStateException  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  else  {  throw  new  IllegalStateException( " ");  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	if(notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  else  {  throw  new  IllegalStateException( " ");  }	          sep    =    sep.finish(f.getPrinter(),    f.getParser());    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	compilable	  [FE]  IllegalStateException  	2	5	replace
267	[BUG]  [BUGGY]  char  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  char  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	char  sep  =  notPrinter.finish(f.getPrinter(),  f.getParser());	  int    sep    =    notPrinter.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	30	None	replace
268	[BUG]  [BUGGY]  if(text  ==  null  ||  text.length()  <  =  0)  {  [CE]  illegal  start  of  expression  [FE]          IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.length()  <  =  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.length()  <  =  0)  {	  if(text    ==    null    ||    text.length()!=    0)    {    if(text    ==    null    ||    text.length()    >=    0)    {    	non-compiled	[CE]  illegal  start  of  expression	52	None	replace
269	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  0);  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  0);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  0);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	67	None	replace
270	[BUG]  [BUGGY]  StaxUtil.sanitizeSeparator(sep,  f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  StaxUtil  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  StaxUtil.sanitizeSeparator(sep,  f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	StaxUtil.sanitizeSeparator(sep,  f.getPrinter(),  f.getParser());	  aught    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol  StaxUtil	73	None	replace
271	[BUG]  [BUGGY]  Sep  <  Object>  sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  <  Object>  sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  <  Object>  sep  =  sep.finish(f,  f.getPrinter(),  f.getParser());	  Sep    <    Object>    sep    =    sep.finish(f.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	68	None	replace
272	[BUG]  [BUGGY]  appendSuffix(text,  null,  true);  [CE]  illegal  start  of  type  [FE]              IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  null,  true);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  null,  true);	  appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	23	None	replace
273	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  >  expected  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  >  expected	77	None	replace
274	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  >  expected  [FE]      IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  >  expected	77	None	replace
275	[BUG]  [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [CE]  >  expected  [FE]        IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	FormatterBuilder  <  STRICT_MODULE_FIRST  ||  text!=  null  &&  text.length()  >  0)  {  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(new  SimpleAffix(text));  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  >  expected	77	None	replace
276	[BUG]  [BUGGY]  MutableFormatterBuilder.appendSuffix(new  SimpleAffix(text));  [CE]  illegal  start  of  type  [FE]          IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  MutableFormatterBuilder.appendSuffix(new  SimpleAffix(text));  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	MutableFormatterBuilder.appendSuffix(new  SimpleAffix(text));	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	77	None	replace
277	[BUG]  [BUGGY]  sep  =  separator.finish(f.getPrinter(),  f.getSeparator());  [CE]  cannot  find  symbol  [FE]        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  separator.finish(f.getPrinter(),  f.getSeparator());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  separator.finish(f.getPrinter(),  f.getSeparator());	  sep    =    sep.finish(f.getPrinter(),    f.getSeparator());    	non-compiled	[CE]  cannot  find  symbol	41	None	replace
278	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  1,  notPrinter,  notParser,  notParser);  [CE]  ')'  expected  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size  -  1,  notPrinter,  notParser,  notParser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size  -  1,  notPrinter,  notParser,  notParser);	  sep    =    sep.finish(elementPairs.subList(2,    size    -    1,    notPrinter,    notParser);    	non-compiled	[CE]  ')'  expected	22	None	replace
279	[BUG]  [BUGGY]  appendSuffix(text,  text);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  appendSuffix(text,  text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	appendSuffix(text,  text);	  appendSuffix(text);    	non-compiled	[CE]  illegal  start  of  type	25	None	replace
280	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()  [CE]  ')'  expected  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()	  	non-compiled	[CE]  ')'  expected	36	None	add
281	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.parser);  [CE]  cannot  find  symbol  parser  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.parser);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  f.parser);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iBeforeParser);    	non-compiled	[CE]  cannot  find  symbol  parser	20	None	replace
282	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  iText);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  iText);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  iText);	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
283	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  null,  iFieldType);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  null,  iFieldType);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  null,  iFieldType);	  TextUtilities.appendSuffix(text,    null);    	non-compiled	[CE]  illegal  start  of  type	24	None	replace
284	[BUG]  [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(elementPairs.getPrinter(),  sep.getParser(),  notPrinter);	  int    sep    =    sep.finish(elementPairs.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	27	None	replace
285	[BUG]  [BUGGY]  TextUtilities.appendSuffix(this,  text);  [CE]  illegal  start  of  type  [FE]                IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(this,  text);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(this,  text);	  TextUtilities.appendSuffix(text,    this);    	non-compiled	[CE]  illegal  start  of  type	70	None	replace
286	[BUG]  [BUGGY]  TextUtilities.appendSuffix(text,  iText);  [CE]  illegal  start  of  type  [FE]                  IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  TextUtilities.appendSuffix(text,  iText);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	TextUtilities.appendSuffix(text,  iText);	  TextUtilities.appendSuffix(text,    this);    	non-compiled	[CE]  illegal  start  of  type	70	None	replace
287	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  butString[i]);  }  [CE]  illegal  start  of  type  [FE]                    IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  butString[i]);  }  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	for(int  i  =  0;  i  <  text.length();  ++i)  {  appendSuffix(text,  butString[i]);  }	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text[i]);    }    	non-compiled	[CE]  illegal  start  of  type	82	None	replace
288	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  sep  +  1));  [CE]  bad  operand  types  for  binary  operator  '+'  [FE]                        IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size,  sep  +  1));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size,  sep  +  1));	  sep    =    sep.finish(elementPairs.subList(2,    size    +    1));    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	6	None	replace
289	[BUG]  [BUGGY]  parent  ==  null  ||  notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent  ==  null  ||  notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent  ==  null  ||  notPrinter  ||  notParser)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	37	None	replace
290	[BUG]  [BUGGY]  parent  ==  null  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]      IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent  ==  null  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent  ==  null  {  sep  =  parent.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	37	None	replace
291	[BUG]  [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  f.getParser(),  size);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(elementPairs.getPrinter(),  f.getParser(),  size);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(elementPairs.getPrinter(),  f.getParser(),  size);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    size);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	32	None	replace
292	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size  +  1));  [CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(1,  size  +  1));  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(1,  size  +  1));	  sep    =    sep.finish(elementPairs.subList(1,    size));    	non-compiled	[CE]  method  finish  in  class  Separator  cannot  be  applied  to  given  types;	59	None	replace
293	[BUG]  [BUGGY]  this.iSingularText  =  text.substring(0,  text.length()  -  1);  [CE]  illegal  start  of  type  [FE]    StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  this.iSingularText  =  text.substring(0,  text.length()  -  1);  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	this.iSingularText  =  text.substring(0,  text.length()  -  1);	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  illegal  start  of  type	81	None	replace
294	[BUG]  [BUGGY]  this.iSingularText  =  text.trim().toLowerCase();  [CE]  illegal  start  of  type  [FE]      StackOverflowError    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  this.iSingularText  =  text.trim().toLowerCase();  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	this.iSingularText  =  text.trim().toLowerCase();	  if(text!=    null)    {    for(int    i    =    0;    i    <    text.length();    ++i)    {    appendSuffix(text);    }    	non-compiled	[CE]  illegal  start  of  type	81	None	replace
295	[BUG]  [BUGGY]  sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  [FE]          IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  f.finish(elementPairs.getPrinter(),  f.getParser());	  sep    =    sep.finish(elementPairs.getPrinter(),    f.getParser());    	non-compiled	[CE]  cannot  find  symbol	42	None	replace
296	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  f.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  f.getParser(),  notPrinter);	  int    sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	75	None	replace
297	[BUG]  [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  parser,  notPrinter);  [CE]  cannot  find  symbol  parser  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(f.getPrinter(),  f.getParser(),  parser,  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(f.getPrinter(),  f.getParser(),  parser,  notPrinter);	  sep    =    sep.finish(f.getPrinter(),    f.getParser(),    notPrinter);    	non-compiled	[CE]  cannot  find  symbol  parser	43	None	replace
298	[BUG]  [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFactory);  [CE]  cannot  find  symbol  notFactory  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFactory);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  sep.finish(elementPairs.subList(2,  size),  notPrinter,  notParser,  notFactory);	  sep    =    sep.finish(elementPairs.subList(2,    size),    notPrinter,    notParser,    iAfterParser);    	non-compiled	[CE]  cannot  find  symbol  notFactory	64	None	replace
299	[BUG]  [BUGGY]  parent  ==  null  ||  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [CE]  not  a  statement  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  parent  ==  null  ||  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	parent  ==  null  ||  notPrinter)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }	          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    	non-compiled	[CE]  not  a  statement	39	None	replace
300	[BUG]  [BUGGY]  int  sep  =  sip.finish(sep.getPrinter(),  sep.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sip.finish(sep.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sip.finish(sep.getPrinter(),  sep.getParser());	  int    sep    =    s.finish(sep.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	29	None	replace
301	[BUG]  [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()  [CE]  ')'  expected  [FE]    IllegalArgumentException    [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]          if(sep!=    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	                if(sep!=        null)        {        sep        =        sep.finish(f.getPrinter(),        f.getParser());        }        if(sep    ==    null)    {    sep    =    sep.finish(f.getPrinter(),    f.getParser());    }    if(sep!=  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser());  }  if(sep  ==  null)  {  sep  =  sep.finish(f.getPrinter(),  f.getParser()	  	non-compiled	[CE]  ')'  expected	38	None	add
302	[BUG]  [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  f.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  f.finish(f.getPrinter(),  sep.getParser(),  notPrinter);	  int    sep    =    f.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	12	None	replace
303	[BUG]  [BUGGY]  sep  =  parser.finish(f.getPrinter(),  sep.getParser());  [CE]  cannot  find  symbol  [FE]                    IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  sep  =  parser.finish(f.getPrinter(),  sep.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	sep  =  parser.finish(f.getPrinter(),  sep.getParser());	  sep    =    sep.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol	34	None	replace
304	[BUG]  [BUGGY]  Integer  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]              IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Integer  sep  =  f.finish(sep.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Integer  sep  =  f.finish(sep.getPrinter(),  f.getParser());	  int    sep    =    f.finish(sep.getPrinter(),    f.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	31	None	replace
305	[BUG]  [BUGGY]  int  sep  =  sep.finish(sep.getPrinter(),  notParser.getParser());  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]                  IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  sep.finish(sep.getPrinter(),  notParser.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  sep.finish(sep.getPrinter(),  notParser.getParser());	  int    sep    =    sep.finish(sep.getPrinter(),    notPrinter.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	28	None	replace
306	[BUG]  [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)  [FE]            IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  int  sep  =  parser.finish(f.getPrinter(),  sep.getParser(),  notPrinter);  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	int  sep  =  parser.finish(f.getPrinter(),  sep.getParser(),  notPrinter);	  int    sep    =    parser.finish(f.getPrinter(),    sep.getParser());    	non-compiled	[CE]  variable  sep  is  already  defined  in  method  toFormatter(List<Object>,boolean,boolean)	85	None	replace
307	[BUG]  [BUGGY]  [FE]  IllegalArgumentException  [FE]        IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.trim().length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	add	if(text  ==  null  ||  text.trim().length()!=  0)  {	  if(text    ==    null    ||    text.length()!=    0)    {    if(text    ==    null    ||    text.length()!=    0)    {    	compilable	  [FE]  IllegalArgumentException  	51	5	replace
308	[BUG]  [BUGGY]  if(text  ==  null  ||  text.trim().length()!=  0)  {  [FE]  IllegalArgumentException  [FE]        IllegalArgumentException      [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  if(text  ==  null  ||  text.trim().length()!=  0)  {  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	if(text  ==  null  ||  text.trim().length()!=  0)  {	  if(text    ==    null    ||    text.length()!=    0)    {    if(text    ==    null    ||    text.length()!=    0)    {    	compilable	  [FE]  IllegalArgumentException  	51	5	replace
309	[BUG]  [BUGGY]  Sep  =  sep.finish(sep.getPrinter(),  f.getParser());  [CE]  cannot  find  symbol  Sep  [FE]                      IllegalArgumentException      [CONTEXT]      private  static  PeriodFormatter  toFormatter(List<Object>  elementPairs,  boolean  notPrinter,  boolean  notParser)  {  if  (notPrinter  &&  notParser)  {  throw  new  IllegalStateException(     "Builder  has  created  neither  a  printer  nor  a  parser     ");  }  int  size  =  elementPairs.size();  if  (size  >=  2  &&  elementPairs.get(0)  instanceof  Separator)  {  Separator  sep  =  (Separator)  elementPairs.get(0);  PeriodFormatter  f  =  toFormatter(elementPairs.subList(2,  size),  notPrinter,  notParser);  sep  =  sep.finish(f.getPrinter(),  f.getParser());      [BUGGY]  Sep  =  sep.finish(sep.getPrinter(),  f.getParser());  [BUGGY]      return  new  PeriodFormatter(sep,  sep);  }  Object[]  comp  =  createComposite(elementPairs);  if  (notPrinter)  {  return  new  PeriodFormatter(null,  (PeriodParser)  comp[1]);  }  else  if  (notParser)  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  null);  }  else  {  return  new  PeriodFormatter((PeriodPrinter)  comp[0],  (PeriodParser)  comp[1]);  }  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  toFormatter  [RETURN_TYPE]  PeriodFormatter  Object>  elementPairs  boolean  notPrinter  boolean  notParser  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodFormatter  f  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  size  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  notParser  notPrinter  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  pairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  Separator  sep  Object[]  comp  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4472135954999579	803	803	1	replace	Sep  =  sep.finish(sep.getPrinter(),  f.getParser());	  sep    =    s.finish(sep.getPrinter(),    sep.getParser());    	non-compiled	[CE]  cannot  find  symbol  Sep	35	None	replace
310	[BUG]  [BUGGY]  MutableFormatter.appendSuffix(new  SimpleAffix(text));  [CE]  illegal  start  of  type  [FE]    IllegalArgumentException    [CONTEXT]      public  PeriodFormatterBuilder  appendSuffix(String  text)  {      [BUGGY]  MutableFormatter.appendSuffix(new  SimpleAffix(text));  [BUGGY]      throw  new  IllegalArgumentException();  }  return  appendSuffix(new  SimpleAffix(text));  }  [CLASS]  PeriodFormatterBuilder  SimpleAffix  PluralAffix  CompositeAffix  FieldFormatter  Literal  Separator  Composite  [METHOD]  appendSuffix  [RETURN_TYPE]  PeriodFormatterBuilder  String  text  [VARIABLES]  PeriodPrinter[]  iPrinters  PeriodParser  beforeParser  iAfterParser  iBeforeParser  parser  PeriodParser[]  iParsers  String  finalText  iFinalText  iPluralText  iSingularText  iText  pluralText  singularText  text  String[]  iParsedForms  variants  int  DAYS  HOURS  MAX_FIELD  MILLIS  MINUTES  MONTHS  PRINT_ZERO_ALWAYS  PRINT_ZERO_IF_SUPPORTED  PRINT_ZERO_NEVER  PRINT_ZERO_RARELY_FIRST  PRINT_ZERO_RARELY_LAST  SECONDS  SECONDS_MILLIS  SECONDS_OPTIONAL_MILLIS  WEEKS  YEARS  fieldType  i  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  maxDigits  maxParsedDigits  minDigits  minPrinted  minPrintedDigits  printZeroSetting  type  PeriodPrinter  beforePrinter  iAfterPrinter  iBeforePrinter  printer  boolean  iNotParser  iNotPrinter  iRejectSignedValues  iUseAfter  iUseBefore  rejectSignedValues  useAfter  useBefore  v  Literal  EMPTY  literal  List  elementPairs  iElementPairs  parserList  printerList  FieldFormatter[]  fieldFormatters  iFieldFormatters  PeriodFieldAffix  iLeft  iPrefix  iRight  iSuffix  left  prefix  right  suffix  	projects/Time27/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java	0.4082482904638631	552	552	1	replace	MutableFormatter.appendSuffix(new  SimpleAffix(text));	  if(text!=    null)    {    for(int    i    =    0,    len    =    text.length();    i    <    len;    ++i)    {    appendSuffix(new    SimpleAffix(text));    }    	non-compiled	[CE]  illegal  start  of  type	79	None	replace
