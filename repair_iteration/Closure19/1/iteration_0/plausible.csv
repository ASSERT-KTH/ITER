13	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  [FE]  IllegalArgumentException  [CONTEXT]  Preconditions.checkNotNull(qualifiedName);  JSType  origType  =  node.getJSType();  origType  =  origType  ==  null  ?  getNativeType(UNKNOWN_TYPE)  :  origType;  scope.inferQualifiedSlot(node,  qualifiedName,  origType,  type);  break;      default:  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +      node.toStringTree());  [BUGGY]  node.toStringTree());  }  }  [CLASS]  ChainableReverseAbstractInterpreter  1  2  RestrictByTypeOfResultVisitor  RestrictByTrueTypeOfResultVisitor  RestrictByFalseTypeOfResultVisitor  RestrictByOneTypeOfResultVisitor  [METHOD]  declareNameInScope  [RETURN_TYPE]  void    FlowScope  scope  Node  node  JSType  type  [VARIABLES]  JSTypeRegistry  typeRegistry  boolean  outcome  resultEqualsValue  JSType  origType  type  Visitor  restrictNullVisitor  restrictUndefinedVisitor  ChainableReverseAbstractInterpreter  firstLink  lastLink  nextLink  CodingConvention  convention  Node  node  String  qualifiedName  value  FlowScope  scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.toStringTree());  }	throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  	plausible		1	0
19	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  [FE]  IllegalArgumentException  [CONTEXT]  Preconditions.checkNotNull(qualifiedName);  JSType  origType  =  node.getJSType();  origType  =  origType  ==  null  ?  getNativeType(UNKNOWN_TYPE)  :  origType;  scope.inferQualifiedSlot(node,  qualifiedName,  origType,  type);  break;      default:  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +      node.toStringTree());  [BUGGY]  node.toStringTree());  }  }  [CLASS]  ChainableReverseAbstractInterpreter  1  2  RestrictByTypeOfResultVisitor  RestrictByTrueTypeOfResultVisitor  RestrictByFalseTypeOfResultVisitor  RestrictByOneTypeOfResultVisitor  [METHOD]  declareNameInScope  [RETURN_TYPE]  void    FlowScope  scope  Node  node  JSType  type  [VARIABLES]  JSTypeRegistry  typeRegistry  boolean  outcome  resultEqualsValue  JSType  origType  type  Visitor  restrictNullVisitor  restrictUndefinedVisitor  ChainableReverseAbstractInterpreter  firstLink  lastLink  nextLink  CodingConvention  convention  Node  node  String  qualifiedName  value  FlowScope  scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.toStringTree());  }	throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  	plausible		1	0
25	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  [FE]  IllegalArgumentException  [CONTEXT]  Preconditions.checkNotNull(qualifiedName);  JSType  origType  =  node.getJSType();  origType  =  origType  ==  null  ?  getNativeType(UNKNOWN_TYPE)  :  origType;  scope.inferQualifiedSlot(node,  qualifiedName,  origType,  type);  break;      default:  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +      node.toStringTree());  [BUGGY]  node.toStringTree());  }  }  [CLASS]  ChainableReverseAbstractInterpreter  1  2  RestrictByTypeOfResultVisitor  RestrictByTrueTypeOfResultVisitor  RestrictByFalseTypeOfResultVisitor  RestrictByOneTypeOfResultVisitor  [METHOD]  declareNameInScope  [RETURN_TYPE]  void    FlowScope  scope  Node  node  JSType  type  [VARIABLES]  JSTypeRegistry  typeRegistry  boolean  outcome  resultEqualsValue  JSType  origType  type  Visitor  restrictNullVisitor  restrictUndefinedVisitor  ChainableReverseAbstractInterpreter  firstLink  lastLink  nextLink  CodingConvention  convention  Node  node  String  qualifiedName  value  FlowScope  scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.toStringTree());  }	throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  	plausible		1	0
25	[BUG]  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  [FE]  IllegalArgumentException  [CONTEXT]  Preconditions.checkNotNull(qualifiedName);  JSType  origType  =  node.getJSType();  origType  =  origType  ==  null  ?  getNativeType(UNKNOWN_TYPE)  :  origType;  scope.inferQualifiedSlot(node,  qualifiedName,  origType,  type);  break;      default:  [BUGGY]  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +      node.toStringTree());  [BUGGY]  node.toStringTree());  }  }  [CLASS]  ChainableReverseAbstractInterpreter  1  2  RestrictByTypeOfResultVisitor  RestrictByTrueTypeOfResultVisitor  RestrictByFalseTypeOfResultVisitor  RestrictByOneTypeOfResultVisitor  [METHOD]  declareNameInScope  [RETURN_TYPE]  void    FlowScope  scope  Node  node  JSType  type  [VARIABLES]  JSTypeRegistry  typeRegistry  boolean  outcome  resultEqualsValue  JSType  origType  type  Visitor  restrictNullVisitor  restrictUndefinedVisitor  ChainableReverseAbstractInterpreter  firstLink  lastLink  nextLink  CodingConvention  convention  Node  node  String  qualifiedName  value  FlowScope  scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.toStringTree());	throw  new  IllegalArgumentException( "Node  cannot  be  refined.  \n "  +  node.toStringTree());  	plausible		1	0
