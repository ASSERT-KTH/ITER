105	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree()   "    +    node.toStringTree());    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree()   "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  node.toStringTree() "  +  node.toStringTree());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree()   "    +    node.toStringTree());    	plausible		495	0
168	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    [CE]    unreachable    statement    [FE]        UnsupportedOperationException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  cannot  be  refined. "  +  node.getClass());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    	plausible		399	0
251	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [FE]    java.lang.IllegalArgumentException:    Node    cannot    be    refined.    Node    defined    with    node.toStringTree()    [FE]            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  node.toStringTree(), "  +  node.toStringTree());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    	plausible		497	0
251	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [FE]    java.lang.IllegalArgumentException:    Node    cannot    be    refined.    Node    defined    with    node.toStringTree()    [FE]            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  node.toStringTree(), "  +  node.toStringTree());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    	plausible		497	0
251	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [FE]    java.lang.IllegalArgumentException:    Node    cannot    be    refined.    Node    defined    with    node.toStringTree()    [FE]            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  node.toStringTree(), "  +  node.toStringTree());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    node.toStringTree(),   "    +    node.toStringTree());    	plausible		497	0
294	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    has    been    refined.   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    has    been    refined.   "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  has  been  refined. "  +  node.getQualifiedName());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    has    been    refined.   "    +    node.getQualifiedName());    	plausible		505	0
330	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [CE]    unreachable    statement    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  cannot  be  refined. "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    	plausible		449	0
330	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [CE]    unreachable    statement    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    	plausible		449	0
330	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [CE]    unreachable    statement    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  can  be  refined. "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    	plausible		449	0
330	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [CE]    unreachable    statement    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  node   "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    	plausible		449	0
330	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [CE]    unreachable    statement    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  node. "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    	plausible		449	0
441	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [CE]    unreachable    statement    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  cannot  be  refined. "  +  node.toStringTree());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    	plausible		419	0
441	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [CE]    unreachable    statement    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  can  be  refined. "  +  node.toStringTree());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    	plausible		419	0
441	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [CE]    unreachable    statement    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  node   "  +  node.toStringTree());	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.toStringTree());    	plausible		419	0
474	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named:   "    +    node.getName());    [CE]    cannot    find    symbol    [FE]                                        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named:   "    +    node.getName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  named: "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named:   "    +    node.getName());    	plausible		245	0
561	[BUG]    [BUGGY]            Preconditions.checkNotNull(type);    Preconditions.checkNotNull(type);    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]            Preconditions.checkNotNull(type);    Preconditions.checkNotNull(type);    [BUGGY]        throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    \n       "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(type!=  null);  Preconditions.checkNotNull(type);	          Preconditions.checkNotNull(type);    Preconditions.checkNotNull(type);    	plausible		23	0
565	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    type       "    +    node.getLineno());    [FE]    IllegalArgumentException    [FE]                    IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    type       "    +    node.getLineno());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  type "  +  node.getLineno());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    type       "    +    node.getLineno());    	plausible		479	0
771	[BUG]    [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [CE]    variable    qualifiedName    might    not    have    been    initialized    [FE]                    UnsupportedOperationException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME  &&  node.getString().length()  >  0)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.getString());  }	  if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    	plausible		42	0
772	[BUG]    [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [CE]    variable    qualifiedName    might    not    have    been    initialized    [FE]                    UnsupportedOperationException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME  &&  node.getString().equals( "name "))  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.getString());  }	  if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.getString());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    	plausible		42	0
891	[BUG]    [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    [FE]    IllegalStateException    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    [BUGGY]        throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    \n       "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(node.getType()!=  Token.FUNCTION);	  Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    	plausible		484	0
897	[BUG]    [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    [FE]    IllegalStateException    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    [BUGGY]        throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    \n       "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(node.getType()  ==  Token.FUNCTION  ||  node.getJSType()!=  type);	  Preconditions.checkState(node.getType()    ==    Token.FUNCTION);    	plausible		484	0
918	[BUG]    [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [CE]    variable    qualifiedName    might    not    have    been    initialized    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME  ||  node.getType()  ==  Token.FUNCTION)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    	plausible		47	0
918	[BUG]    [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [CE]    variable    qualifiedName    might    not    have    been    initialized    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.FUNCTION)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    	plausible		47	0
918	[BUG]    [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [CE]    variable    qualifiedName    might    not    have    been    initialized    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME  ||  node.getType()  ==  Token.GETPROP)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(node.getType()    ==    Token.NAME)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.       "    +    node.toStringTree());    }    else    {    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    }    	plausible		47	0
1006	[BUG]    [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    can    be    refined.   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]                        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    can    be    refined.   "    +    node.toStringTree());    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  can  be  refined. "  +  node.toStringTree());  }	  if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    can    be    refined.   "    +    node.toStringTree());    }    	plausible		87	0
1188	[BUG]    [BUGGY]    Preconditions.checkArgument(type!=    null    &&    type.isUnknownType());    [FE]    IllegalArgumentException    [FE]                        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    Preconditions.checkArgument(type!=    null    &&    type.isUnknownType());    [BUGGY]        throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    \n       "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkArgument(type!=  null  ||  type.isUnknownType());	  Preconditions.checkArgument(type!=    null    &&    type.isUnknownType());    	plausible		344	0
1212	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    Node    node    =    node.getFirstChild();    [CE]    variable    node    is    already    defined    in    method    declareNameInScope(FlowScope,Node,JSType)    [FE]                    UnsupportedOperationException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    Node    node    =    node.getFirstChild();    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	node  =  node.getFirstChild();	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getString());    Node    node    =    node.getFirstChild();    	plausible		57	0
1223	[BUG]    [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    can    be    refined.   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]                        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    can    be    refined.   "    +    node.toStringTree());    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  can  be  refined. "  +  node.toStringTree());  }	  if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    can    be    refined.   "    +    node.toStringTree());    }    	plausible		7	0
1308	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    type    must    be    in    the    range    [   "    +    node.getString());    [FE]    UnsupportedOperationException    [FE]                        UnsupportedOperationException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    type    must    be    in    the    range    [   "    +    node.getString());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  type  must  be  in  the  range  [ "  +  node.getString());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    type    must    be    in    the    range    [   "    +    node.getString());    	plausible		466	0
1369	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    if(Node    cannot    be    refined.    n       "    +    node.getQualifiedName())    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    }    [CE]    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    if(Node    cannot    be    refined.    n       "    +    node.getQualifiedName())    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  n "  +  node.getQualifiedName());  }	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    if(Node    cannot    be    refined.    n       "    +    node.getQualifiedName())    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n       "    +    node.getQualifiedName());    }    	plausible		447	0
1391	[BUG]    [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]                            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  node: "  +  node.toStringTree());  }	  if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    	plausible		9	0
1396	[BUG]    [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]                            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined,  node: "  +  node.toStringTree());  }	  if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    node:   "    +    node.toStringTree());    }    	plausible		9	0
1456	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named    with    qualified    name    '   "    +    node.getName());    [CE]    cannot    find    symbol    [FE]                                                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named    with    qualified    name    '   "    +    node.getName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  named  with  qualified  name  ' "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    named    with    qualified    name    '   "    +    node.getName());    	plausible		247	0
1497	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name       "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name       "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  qualified  name "  +  node.getQualifiedName());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name       "    +    node.getQualifiedName());    	plausible		503	0
1574	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    must    be    in    the    range    [   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]                        IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    must    be    in    the    range    [   "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  must  be  in  the  range  [ "  +  node.getQualifiedName()  + "] ");	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    must    be    in    the    range    [   "    +    node.getQualifiedName());    	plausible		511	0
1586	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getLineno());    Node    cannot    be    refined.    n       "    +    node.getLineno());    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    [CE]    [FE]                IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getLineno());    Node    cannot    be    refined.    n       "    +    node.getLineno());    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getLineno());  }	  throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    n       "    +    node.getLineno());    Node    cannot    be    refined.    n       "    +    node.getLineno());    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    	plausible		165	0
1700	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]                            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  qualified  name  ' "  +  node.getQualifiedName());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    	plausible		80	0
1700	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]                            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    [BUGGY]        node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.  Node  defined  with  qualified  name  ' "  +  node.getQualifiedName()  + "' ");	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    Node    defined    with    qualified    name    '   "    +    node.getQualifiedName());    	plausible		80	0
1756	[BUG]    [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.NAME);    [FE]    IllegalStateException    [FE]            IllegalArgumentException        [CONTEXT]        Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:        [BUGGY]    Preconditions.checkState(node.getType()    ==    Token.NAME);    [BUGGY]        throw    new    IllegalArgumentException(       "Node    cannot    be    refined.    \n       "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(node.getType()!=  Token.NAME);	  Preconditions.checkState(node.getType()    ==    Token.NAME);    	plausible		482	0
