3	[BUG]    [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]                    IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(type!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    	plausible		16	0
39	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    type.toStringTree());    [CE]    cannot    find    symbol    [FE]        IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    type.toStringTree());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.toStringTree());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    type.toStringTree());    	plausible		37	0
41	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    [FE]    UnsupportedOperationException    [FE]                IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getString());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    	plausible		40	0
46	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node.getType()  ==  Token.NAME)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.toStringTree());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    	plausible		12	0
75	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]                                    IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getQualifiedName());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    	plausible		21	0
84	[BUG]    [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    	plausible		24	0
86	[BUG]    [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [FE]    IllegalArgumentException    [FE]        IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.  Node  cannot  be  refined. "  +  node.toStringTree());  }	  if(node!=    null)    {    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.toStringTree());    }    	plausible		24	0
267	[BUG]    [BUGGY]        Preconditions.checkNotNull(type);    [FE]    IllegalArgumentException    [FE]            IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]        Preconditions.checkNotNull(type);    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    \n   "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(type!=  null);	      Preconditions.checkNotNull(type);    	plausible		28	0
269	[BUG]    [BUGGY]        Preconditions.checkNotNull(type);    [FE]    IllegalArgumentException    [FE]            IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]        Preconditions.checkNotNull(type);    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    \n   "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkArgument(type!=  null);	      Preconditions.checkNotNull(type);    	plausible		28	0
273	[BUG]    [BUGGY]        Preconditions.checkNotNull(type);    [FE]    IllegalArgumentException    [FE]            IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]        Preconditions.checkNotNull(type);    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    \n   "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkState(!type.isUnknownType());	      Preconditions.checkNotNull(type);    	plausible		28	0
275	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getLineno());    [FE]    IllegalArgumentException    [FE]                        IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getLineno());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getLineno());	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getLineno());    	plausible		18	0
284	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    [FE]    UnsupportedOperationException    [FE]                IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(node  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getString());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getString());    	plausible		40	0
331	[BUG]    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    [FE]    IllegalArgumentException    [FE]                                    IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    [BUGGY]    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	if(type  ==  null)  {  throw  new  IllegalArgumentException( "Node  cannot  be  refined.   "  +  node.getQualifiedName());  }	  throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    n   "    +    node.getQualifiedName());    	plausible		21	0
481	[BUG]    [BUGGY]        Preconditions.checkNotNull(type);    [FE]    IllegalArgumentException    [FE]            IllegalArgumentException    [CONTEXT]    Preconditions.checkNotNull(qualifiedName);    JSType    origType    =    node.getJSType();    origType    =    origType    ==    null    ?    getNativeType(UNKNOWN_TYPE)    :    origType;    scope.inferQualifiedSlot(node,    qualifiedName,    origType,    type);    break;        default:    [BUGGY]        Preconditions.checkNotNull(type);    [BUGGY]    throw    new    IllegalArgumentException(   "Node    cannot    be    refined.    \n   "    +        node.toStringTree());    node.toStringTree());    }    }    [CLASS]    ChainableReverseAbstractInterpreter    1    2    RestrictByTypeOfResultVisitor    RestrictByTrueTypeOfResultVisitor    RestrictByFalseTypeOfResultVisitor    RestrictByOneTypeOfResultVisitor    [METHOD]    declareNameInScope    [RETURN_TYPE]    void    FlowScope    scope    Node    node    JSType    type    [VARIABLES]    JSTypeRegistry    typeRegistry    boolean    outcome    resultEqualsValue    JSType    origType    type    Visitor    restrictNullVisitor    restrictUndefinedVisitor    ChainableReverseAbstractInterpreter    firstLink    lastLink    nextLink    CodingConvention    convention    Node    node    String    qualifiedName    value    FlowScope    scope    	projects/Closure19/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java	1.0	175	176	1	replace	Preconditions.checkArgument(!type.isUnknownType());	      Preconditions.checkNotNull(type);    	plausible		28	0
