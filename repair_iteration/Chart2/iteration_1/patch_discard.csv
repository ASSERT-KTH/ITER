increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.max(2.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.min(2.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.max(0.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.min(0.0, 0.0);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum, uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if( includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount();
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol,   ,int categoryCount = dataset.getColumnCount();
compilation error,[CE] variable series is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int series = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Math.min(0.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Math.max(0.0, 0.0);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Math.max(0.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Math.min(0.0, 1.0);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; bodied else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY)!= return null; }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); bodied
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; bodied
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum =(double)Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol INTEGER_INFINITY,   ,double maximum =(double)Double.INTEGER_INFINITY;
compilation error,[CE] cannot find symbol NEVER_INFINITY,   ,double maximum =(double)Double.NEVER_INFINITY;
compilation error,[CE] cannot find symbol NULL_INFINITY,   ,double maximum =(double)Double.NULL_INFINITY;
compilation error,[CE] cannot find symbol NONE,   ,double maximum =(double)Double.NONE;
compilation error,[CE] cannot find symbol INFINITY,   ,double maximum =(double)Double.INFINITY;
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null;!= else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; >> else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); [Delete]
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null;!= else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( "Undefined variable:" + dataset.getClass().getName()); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] cannot find symbol series,   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getColumnCount();
compilation error,[CE] cannot find symbol series,   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getReseriesCount();
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount();
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval)!= return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum << Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new IllegalArgumentException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum == maximal) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.POSITIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY % 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println( "Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isMinimum(lvalue)) {
compilation error,[CE] cannot find symbol local, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(local)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(value)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Integer.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY; Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY ** Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol,   ,int categoryCount = dataset.getColumnCount();
compilation error,[CE] variable series is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int series = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getRowCount();
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isSeriesVisibleInLegend(series)&&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(10.0, 0.0);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(3.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(20.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol INTEGER_INFINITY,   ,double maximum =(double)Double.INTEGER_INFINITY;
compilation error,[CE] cannot find symbol NEVER_INFINITY,   ,double maximum =(double)Double.NEVER_INFINITY;
compilation error,[CE] cannot find symbol NULL_INFINITY,   ,double maximum =(double)Double.NULL_INFINITY;
compilation error,[CE] cannot find symbol NONE,   ,double maximum =(double)Double.NONE;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
patch is same with buggy,, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] incompatible types, float  seriesCount  =  dataset.getSeriesCount();    ,boolean seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] incompatible types, float  seriesCount  =  dataset.getSeriesCount();    ,Double seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] IllegalArgumentException, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,single seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getSecondYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getBeginningYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getStartBounds(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol includesInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includesInterval) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol containsInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || containsInterval) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  maximum)  {    ,if(minimum > max) {
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) }
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum)!=
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) [Delete]
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] generics are not supported in -source 1.4, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) >=
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
increase failing tests, [FE] ArrayIndexOutOfBoundsException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, u
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!IncludeInterval) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue <= 0.0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > maximal) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimal) {
compilation error,[CE] cannot find symbol minumum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minumum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
patch is same with buggy,, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] bad operand types for binary operator '<', if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum < null) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&',   ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY/ Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE, Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE, Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY & Integer.MIN_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MIN_VALUE;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(?Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol $Double, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if($Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() [BUGGY] 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() [PATCH] 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() [BUG] 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
increase failing tests, [FE] NullPointerException, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] illegal start of expression, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) } minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) } minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) } return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= return new Range(minimum, maximum); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else == return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >= return new Range(minimum, maximum); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if( includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, u
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum,
compilation error,[CE] cannot find symbol IncludeInterval, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!IncludeInterval) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean), for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item));
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);double xx = ixyd.getYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getEndXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getEndYValue(series, item);
compilation error,[CE] incompatible types, double  i  =  ixyd.getStartXValue(series,  item);    ,Double xx = ixyd.getXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getChronologyValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getSecondYValue(series, item);
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; bodied
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximal); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; >>
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; toured
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Possibly
compilation error,[CE] illegal start of expression, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY)!= return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Frequently
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.5, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.001, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(3.0, 3.0);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] '.class' expected,   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(
compilation error,[CE] not a statement,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(lvalue)) { minimum
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum, l); }
compilation error,[CE] '.class' expected,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { dataset.getDatasetEntry(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(l)) { l = ixyd.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.NEGATIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NUMBER_INFINITY,   ,double maximum = Double.POSITIVE_INFINITY * Double.NUMBER_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) &&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l= ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)+ 1;
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,Double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,triple l = ixyd.getStartYValue(series, item);
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println( "Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAXIMUM_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NUMBER_INT;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NUMBER_FLOAT;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.ZERO;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable uvalue might not have been initialized,   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)) } minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) } minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, u
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!IncludeInterval) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE - 1;
compilation error,[CE] bad operand types for binary operator '&',   ,double minimum = Double.POSITIVE_INFINITY & Integer.MIN_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE / 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, minimum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.POSITIVE_INFINITY);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.max(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, probability);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, error);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, 0);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.ERROR);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, false);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 2.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.min(0.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, 0.0);
patch is same with buggy,, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] '.class' expected,   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(
compilation error,[CE] not a statement,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(lvalue)) { minimum
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum, l); }
compilation error,[CE] '.class' expected,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { dataset.getDatasetEntry(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(l)) { l = ixyd.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new IllegalArgumentException(""); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] ')' expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item
compilation error,[CE] incompatible types, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(ixyd)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(value)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException( "Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected,   ,lvalue = intervalXYData.getStartXValue(series, item));
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 1; series < seriesCount; series++) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1L;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 3;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includesInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || containsInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > max) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | 1;
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) } return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= return new Range(minimum, maximum); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else == return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >= return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); >>
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue <= 0.0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > maximal) {
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); >>
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); bodied
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); [Delete]
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum);!=
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); Possibly
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; [Delete] else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null;!= else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) }
compilation error,[CE] illegal start of expression,   ,if(minimum >= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval)!= return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException( " "); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY;
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new IllegalArgumentException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] '.class' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(double minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(maximum < 0) { minimum = Minimum.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(minimum > maximum) { double minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;double maximum = Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected,   ,lvalue = intervalXYData.getStartXValue(series, item));
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; bodied else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY)!= return null; }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); bodied
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] not a statement,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; bodied
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); }
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(value)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimal) {
compilation error,[CE] cannot find symbol minumum, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minumum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] bad operand types for binary operator '<', if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum < null) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(ixyd)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartXValue(series, item);
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] method getSeriesCount in interface SeriesDataset cannot be applied to given types;, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(0);
compilation error,[CE] cannot find symbol series, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] non-static variable this cannot be referenced from a static context, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = this.dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY / 2;
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l= ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)+ 1;
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,Double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,triple l = ixyd.getStartYValue(series, item);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY - 1;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; bodied
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximal); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; >>
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; toured
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Possibly
compilation error,[CE] illegal start of expression, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY)!= return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Frequently
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum, uvalue)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 1) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double max = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isSeriesVisibleInLegend(series)&&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1L;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 3;
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY / 2;
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartZeroValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStart0Value(series, item);
compilation error,[CE] ';' expected, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item));
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getStartYValue(series, item); Double i = ixyd.getEndXValue(series, item);
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getStartXValue(series, item); Double i = ixyd.getEndYValue(series, item);
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getStartYValue(series, item);double i = ixyd.getEndXValue(series, item);
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getEndXValue(series, item); Double i = ixyd.getStartYValue(series, item);
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getStartYValue(series, item); Double i = ixyd.getEndYValue(series, item);
compilation error,[CE] variable i is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double i = ixyd.getStartYValue(series, item);double i = ixyd.getEndYValue(series, item);
compilation error,[CE] incompatible types,   ,double i = ixyd.getStartXValue(series, item); Double j = ixyd.getEndYValue(series, item);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol $Double, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if($Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY; } if(double minimum > Integer.MAX_VALUE) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(double minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(minimum > 0) { minimum = Double.POSITIVE_INFINITY; }
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, l
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { minimum = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue
compilation error,[CE] 'else' without 'if',   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); u
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); } lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { minimum = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum,
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || minimum > Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum > Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1L;
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < 1.0)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval && uvalue > 0.0 && dataset.getXValue(series, item)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < this.maximum)) {
compilation error,[CE] cannot find symbol upperBounds, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < upperBounds)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < maximum)) {
compilation error,[CE] cannot find symbol MILLIS_PER_SECOND, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < MILLIS_PER_SECOND)) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval &&(uvalue > 0.0 && uvalue < dataset.getItemCount())) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 3;
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
increase failing tests, [FE]  Size, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] cannot find symbol nullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, nullPointerException);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, null);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&',   ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY/ Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY *(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval, Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 1; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isInfinite(boolean), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(false)) {
compilation error,[CE] method hashCode in class Object cannot be applied to given types;, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(hashCode(lvalue))) {
compilation error,[CE] cannot find symbol wh2, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(wh2)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol includesInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includesInterval) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol containsInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || containsInterval) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  maximum)  {    ,if(minimum > max) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol NONEMPTY_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NONEMPTY_INFINITY / 2.0;
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getSecondYValue(series, item);
compilation error,[CE] incompatible types, double  i  =  ixyd.getStartYValue(series,  item);    ,Double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] double cannot be dereferenced, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0 &&!maximum.equals(Math.max(maximum, uvalue))) {
increase failing tests, [FE] NullPointerException, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0) {
compilation error,[CE] cannot find symbol Feature, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0 && isEnabled(Feature.AUTO_CLOSE_SOURCE)) {
compilation error,[CE] ')' expected, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0 &&!maximum instanceof Math.max(maximum, uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0 &&!maximum.equals(dataset.getSeriesCount())) {
compilation error,[CE] cannot find symbol, if(uvalue  >  0.0)  {    ,if(!includeInterval && uvalue > 0.0 &&!maximum.equals(getMaximumValue())) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NUMBER_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NUMBER_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression,   ,double maximum = Double.NEGATIVE_INFINITY ** Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue > maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| that(uvalue > 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { maximum = Math.max(maximum, uvalue); }
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) { maximum = Math.max(maximum, uvalue); }
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum) { if(minimum > maximum) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum) { if(minimum > maximum) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) { if(minimum > minimum) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(minimum > minimum) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(minimum > minimum) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimal) { if(minimum > maximum) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum) { if(minimum > maximum) { return null; } else { return new Range(minimum, maximal); }
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum) { if(minimum > maximum) { return Null; } else { return new Range(minimum, maximum); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(Lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
increase failing tests, [FE]  Size, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] cannot find symbol nullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, nullPointerException);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, null);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol,   ,int categoryCount = dataset.getColumnCount();
compilation error,[CE] variable series is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int series = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getRowCount();
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item - 1);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] ';' expected, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item));
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartxValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY | Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NONEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NONEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximal = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1L;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 3;
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,Float itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] incompatible types,   ,Double itemCount = dataset.getItemCount(series);
compilation error,[CE] cannot find symbol,   ,float itemCount = dataset.getColumnCount();
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) }
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum)!=
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) [Delete]
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] generics are not supported in -source 1.4, if(minimum  >=  maximum)  {    ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) >=
compilation error,[CE] incompatible types, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,Double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | 1;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(seriesCount)) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, 0);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getXYValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeries(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getItemCount(series);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected,   ,lvalue = intervalXYData.getStartXValue(series, item));
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new IllegalArgumentException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); }
patch is same with buggy,, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds;
compilation error,[CE] non-static variable this cannot be referenced from a static context, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)this.dataset, iterateRangeBounds;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds);
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds + 1;
compilation error,[CE] variable series is already defined in method iterateRangeBounds(XYDataset,boolean), IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, series;
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimal) {
compilation error,[CE] cannot find symbol minumum, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minumum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] bad operand types for binary operator '<', if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum < null) {
patch is same with buggy,, return  new  Range(minimum,  maximum);    ,return new Range(minimum, maximum);
compilation error,[CE] cannot find symbol, return  new  Range(minimum,  maximum);    ,if(size() > 0) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] cannot find symbol minimal, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(maximum, minimal); }
compilation error,[CE] cannot find symbol, return  new  Range(minimum,  maximum);    ,if(size() > 0) { return new Range(minimum, maximum); } else { return new Range(minimum, maximum); }
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, 0);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getXYValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeries(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getItemCount(series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset =(Range XYDataset)dataset, iterateRangeBounds;
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = iterateRangeBounds;
compilation error,[CE] ';' expected,   ,Range XYDataset dataset =(Range XYDataset)dataset.getRange();
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = Sets.newHashSet();
compilation error,[CE] ';' expected,   ,Range XYDataset dataset =(Range)dataset.getRange();
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(Series);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset =(Range XYDataset)dataset.getRangeBounds();
compilation error,[CE] ';' expected,   ,Range XYDataset dataset =(Range XYDataset)dataset;
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(minimum > maximum) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] illegal start of expression,   ,if(this.minimum > maximum) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(minimum > maximum) { return new Range(minimum, maximum); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] unreachable statement,   ,if(minimum > maximum) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) { if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(minimum < maximum) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException( "Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NeGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NUMBER_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NUMBER_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NaN;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { maximum = Math.max(maximum, uvalue); }
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) { maximum = Math.max(maximum, uvalue); }
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(?Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol $Double, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if($Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue < 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue <= 0.0)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
patch is same with buggy,, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xxyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartQValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStart0Value(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartJValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartBounds(series, item);
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol InfiniteInterval,   ,double minimum = InfiniteInterval +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = (includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected,   ,double minimum = includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected,   ,double minimum = includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(ixyd)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(?Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol $Double, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if($Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximal) {
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); bodied
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); >>
increase failing tests, [FE]  double), if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); [Delete]
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum);!=
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); Possibly
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null;!= else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; [Delete] else { return new Range(minimum, maximum); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double max = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(this.dataset, false);
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null;!= else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
increase failing tests, [FE]  double), if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); >>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); >>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); [Delete]
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; >>
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] unclosed string literal, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,throw new NullPointerException(" ');
compilation error,[CE] incompatible types, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,return new NullPointerException(" ");
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(value)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) } return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval)!= return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] cannot find symbol includesInterval,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includesInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval);!=
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isSeriesVisibleInLegend(series)&&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY ** Double.POSITIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; >>
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.NEGATIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAXIMUM_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NUMBER_INT;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.FALSE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.NUMBER_FLOAT;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE; >> double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE; < double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] '.class' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY; } if(double minimum > Integer.MAX_VALUE) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] '.class' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(double minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(minimum > 0) { minimum = Double.POSITIVE_INFINITY; }
increase failing tests, [FE] NullPointerException, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
increase failing tests, [FE] NullPointerException, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; >> double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] generics are not supported in -source 1.4, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; < double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; [Delete] double maximum = Double.NEGATIVE_INFINITY; }
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount()!= 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException( "Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset!= null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval)!= return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException( " "); }
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY - 1;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; >>
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression,   ,double maximum = Double.NEGATIVE_INFINITY ** Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isSeriesVisibleInLegend(series)&&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includesInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || containsInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > max) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, l
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { minimum = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue
compilation error,[CE] 'else' without 'if',   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); u
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); } lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] illegal start of type,   ,if(intervalXYData.getStartXValue(series, item)) { minimum = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(intervalXYData.getStartXValue(series, item)) { lvalue = intervalXYData.getStartXValue(series, item); } if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(maximum)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)) ||!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue))) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&',   ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY* Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NONEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NONEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY | Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY ** Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol GATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.GATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(maximum, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(maximum, Double.NEGATIVE_INFINITY)/ 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(maximum, Double.NEGATIVE_INFINITY / 2.0);
compilation error,[CE] cannot find symbol NaN_INFINITY,   ,double maximum = Double.NaN_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY % 2.0;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) }
compilation error,[CE] illegal start of expression,   ,if(minimum >= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue!= null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue < null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue < maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue < null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue!= null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue <= null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue >= maximum) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NeGATIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.MAX_VALUE;
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
increase failing tests, [FE] NullPointerException, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] illegal start of expression, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) } minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) } minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || maximum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimal > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimal || maximum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || maximum > minimal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || maximum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || maximum > limit) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || maximum > minimum) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE * Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol maximum,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE; maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 1; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 1; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item!= itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected,   ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected,   ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval && Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected,   ,lvalue = intervalXYData.getStartXValue(series, item));
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable uvalue might not have been initialized,   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum, lvalue); }
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)) } minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) } minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, lvalue); }
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
increase failing tests, [FE] ArrayIndexOutOfBoundsException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) &&!Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY ** Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] incompatible types, double  xyd  =  ixyd.getStartYValue(series,  item);    ,Double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getEndXValue(series, item);
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item - 1);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] ';' expected, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item));
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] ';' expected,   ,lvalue = intervalXYData.getStartXValue(series, item));
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginningXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; fiance
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bodied
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bod
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; & }
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; lasted
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; figured
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; Afterward
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; >>
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; meanwhile
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | 1;
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!includeInterval && uvalue > 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue < 0.0) {
compilation error,[CE] no suitable method found for iterateRangeBounds(), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!includeInterval && iterateRangeBounds()) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!includeInterval && dataset instanceof OHLCDataset) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!includeInterval && uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(); if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) } double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) < double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) >> double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval)!= double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; >>
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum, uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY; } if(double minimum > Integer.MAX_VALUE) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(double minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(minimum > 0) { minimum = Double.POSITIVE_INFINITY; }
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( "Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( "Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException( "Undefined variable:" + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset!= null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 1) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol,   ,float rangeCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRangeCount();
compilation error,[CE] incompatible types,   ,Double seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = dataset.getRange();
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol InfiniteInterval,   ,double minimum = InfiniteInterval +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected,   ,double minimum = includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = (includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected,   ,double minimum = includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimal) {
compilation error,[CE] cannot find symbol minumum, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minumum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] bad operand types for binary operator '<', if(minimum  >=  maximum)  {    ,if(minimum > maximum || maximum < null) {
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] non-static variable this cannot be referenced from a static context, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = this.dataset.getItemCount(series-1);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-2);
compilation error,[CE] non-static variable this cannot be referenced from a static context, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = this.dataset.getItemCount(series-0);
compilation error,[CE] non-static variable this cannot be referenced from a static context, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = this.dataset.getItemCount(series-2);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-3);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-0, itemCount);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-0, 0);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,float itemCount = dataset.getItemCount(series-1);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) }
patch is same with buggy,, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item)+ 1;
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getBeginningYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStart0Value(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum || uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < 1.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval && uvalue > 0.0 && dataset.getXValue(series, item)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < this.maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < upperBounds)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < MILLIS_PER_SECOND)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&(uvalue > 0.0 && uvalue < dataset.getItemCount())) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression,   ,double maximum = Double.NEGATIVE_INFINITY ** Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isVisible(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Maximum,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) { Maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null;!= else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; [Delete] else { throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; < else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null;!= else { throw new NullPointerException(" "); }
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Math.min(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.min(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] incompatible types,   ,Double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Math.max(0.0, Double.NeGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 0.0);
compilation error,[CE] cannot find symbol NONEMPTY_INFINITY,   ,double maximum = Math.max(0.0, Double.NONEMPTY_INFINITY);
compilation error,[CE] incompatible types,   ,Double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol,   ,triple l = ixyd.getStartYValue(series, item);
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] bad operand types for binary operator '||', double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY || Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(mean)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(value)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum == maximal) {
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] method getSeriesCount in interface SeriesDataset cannot be applied to given types;, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(0);
compilation error,[CE] cannot find symbol series, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] non-static variable this cannot be referenced from a static context, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = this.dataset.getSeriesCount();
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY | Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NONEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NONEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
compilation error,[CE] cannot find symbol showCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < showCount; series++) {
compilation error,[CE] cannot find symbol volumeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < volumeCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(?Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if($Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimal) {
compilation error,[CE] cannot find symbol minumum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minumum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
patch is same with buggy,, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] bad operand types for binary operator '<', if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum < null) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || minimum > Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum > Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isExterns() ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '+', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)+ 1 || Double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&',   ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY/ Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol includesInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includesInterval) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum > maximum || includeInterval) {
compilation error,[CE] cannot find symbol containsInterval, if(minimum  ==  maximum)  {    ,if(minimum > maximum || containsInterval) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  maximum)  {    ,if(minimum > max) {
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] cannot find symbol series,   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getColumnCount();
compilation error,[CE] cannot find symbol series,   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getReseriesCount();
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount();
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NeGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, 0);
compilation error,[CE] ';' expected,   ,Range XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getXYValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double lvalue = ixyd.getStartYValue(series, series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeries(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getItemCount(series);
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); bodied
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Afterward
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); >>
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Eventually
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Possibly
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null;!= else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Ultimately
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
patch is same with buggy,, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getChronologyValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getWidthValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getxValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item + 1);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getZValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getExValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
patch is same with buggy,, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimal > maximum) {
compilation error,[CE] cannot find symbol limit, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > limit) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > minimum || maximum > minimum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal || minimum > maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > minimal) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] cannot find symbol item,   ,double lvalue = dataset.getYValue(series, item);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double itemCount = dataset.getColumnCount(series);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if', double  l  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if', double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression, double  l  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(
compilation error,[CE] not a statement, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN(lvalue)) { minimum
compilation error,[CE] 'else' without 'if', double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum, l); }
compilation error,[CE] illegal start of expression, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { dataset.getDatasetEntry(series, item); if(!Double.isNaN(l)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if', double  l  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(l)) { l = ixyd.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, double  l  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(l)) { l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLocal(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY; } if(double minimum > Integer.MAX_VALUE) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(double minimum > maximum) { minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(minimum > 0) { minimum = Double.POSITIVE_INFINITY; }
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum, uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type,   ,if(!IncludeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); } else { lvalue = intervalXYData.getEndXValue(series, item); if(!
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NeGATIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.MAX_VALUE;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getXYValue(series, 0);
increase failing tests, [FE]  Size,   ,double xx = dataset.getXValue(series, 0);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getYValue(series, 0);
compilation error,[CE] variable uvalue is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double uvalue = ixyd.getStartYValue(series, 0);
increase failing tests, [FE] NullPointerException,   ,double xyd = dataset.getYValue(series, 0);
compilation error,[CE] cannot find symbol,   ,double xx = dataset.getXYValue(series, 0);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-2);
compilation error,[CE] variable lvalue is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double lvalue = dataset.getYValue(series, 0);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item } itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] ')' expected, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() [BUGGY] 0) {
compilation error,[CE] ')' expected, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() [PATCH] 0) {
compilation error,[CE] ')' expected, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() [BUG] 0) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum, u
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { maximum = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!IncludeInterval) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasXValue(series, item)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) &&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
patch is same with buggy,, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartZValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getInitialXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i= ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartQValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartBounds(series, item);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NONEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NONEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY | Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY ** Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol GATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.GATIVE_INFINITY;
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] no suitable method found for isNaN(IntervalXYDataset), for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(ixyd)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,Double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double ixyd = ixyd.getStartXValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double lvalue = ixyd.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if( includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLong(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
patch is same with buggy,, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * Double.NeGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NUMBER_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * Double.NUMBER_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * Double.NaN;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] method hashCode in class Object cannot be applied to given types;, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(hashCode(lvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(lvalue)) }
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset!= null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 1) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(double.isNaN(uvalue)|| double.isNaN(lvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol minimum,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type,   ,if(includeInterval) { minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; >>
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(maximum)) {
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null;!= else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); >>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); [Delete]
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; [Delete] else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] bad operand types for binary operator '||', double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY || Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '&', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY & Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY // Integer.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimal) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null;!= else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; [Delete] else { throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; < else { throw new NullPointerException(" "); }
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(xYDataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.IterateDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol ITERATE_DOMA_BOUNDS, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.ITERATE_DOMA_BOUNDS, false);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(value)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(maximum)) {
patch is same with buggy,, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 2) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isMinimum(lvalue)) {
compilation error,[CE] cannot find symbol local, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isLong(local)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(double.isNaN(uvalue)|| double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isLong(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" ");
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( " ");
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException(" "); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException( " "); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException(" "); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException( " "); } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { throw new NullPointerException(" "); } else >> return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { throw new NullPointerException(" "); } else!= return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { throw new NullPointerException( " "); } else >> return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null;!= else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; [Delete] else { throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; < else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null;!= else { throw new NullPointerException(" "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(itemCount)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximal) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue instanceof Number)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue instanceof DoubleTree)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue instanceof DoubleValue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue instanceof DoubleTitle)) {
compilation error,[CE] cannot find symbol limit, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum || uvalue > limit) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue instanceof DoubleDigit)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval && Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Long.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(this.includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(4.0, 0.0);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(3.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(5.0, 0.0);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double max = Math.max(2.0, 0.0);
increase failing tests, [FE] NullPointerException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-0, itemCount);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-2);
compilation error,[CE] non-static variable this cannot be referenced from a static context, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = this.dataset.getItemCount(series-1);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] int cannot be dereferenced, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1).length;
compilation error,[CE] cannot find symbol one, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-one);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series -1);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-3);
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NumberInput, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = NumberInput.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Number.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NeGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(maximum)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)/> Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY -(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY *(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = (includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
patch is same with buggy,, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xxyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getInitialXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getSTARtYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.startYValue(series, item);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getInitialYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getMeanYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double max = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");!=
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); <
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Integer.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Integer.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol MIN_VALUE, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Math.MIN_VALUE + Integer.MAX_VALUE * Integer.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = 0 + Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '*', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)*!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NaN, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)NaN.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol MAXIMUM_VALUE, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.MAXIMUM_VALUE;
patch is same with buggy,, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getRange() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getItemCount() > 0) {
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol mvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,mvalue = intervalXYData.getEndXValue(series, item);
increase failing tests, [FE] AssertionFailedError, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,gvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol bvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,bvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,jvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ivalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,ivalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeValue(series, item);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Double.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSequenceCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSingleDomainCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSerialCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRemainingCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRuleCount();
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] 'else' without 'if',   ,while(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(includeInterval) { return this; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < throw new NullPointerException(" "); }
compilation error,[CE] 'else' without 'if',   ,while(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,[Delete]
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); meanwhile
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); Toujours
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); Alternatively
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); [Delete]
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY | Double.MAX_VALUE;
increase failing tests, [FE] NullPointerException, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; }
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,Double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY - Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } else { DatasetUtilities.setDomainBounds(minimum, maximum); }
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Math.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(interval)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData,   ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Double.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Long.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");!=
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >=
compilation error,[CE] generics are not supported in -source 1.4, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); <
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getStartYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getStartYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); if(!Double.isNaN(series)) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getSerialCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRangeBounds();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRemainderCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getSecondCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRange();
patch is same with buggy,, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getxValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getChksumValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.setXValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getChronology(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getZValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double yyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double j = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSingleDomainCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSerialCount();
compilation error,[CE] cannot find symbol series, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol min, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == min) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == maximum) {
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol mvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,mvalue = intervalXYData.getEndXValue(series, item);
increase failing tests, [FE] AssertionFailedError, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,gvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol bvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,bvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,jvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ivalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,ivalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeValue(series, item);
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData,   ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValu
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return maximum; }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { max = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maxim, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - 1; double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; double max = Double.NEGATIVE_INFINITY; }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)*!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } second = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Math.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getChksumValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getxValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getComparableValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getZValue(series, item);
compilation error,[CE] incompatible types, double  i  =  ixyd.getStartXValue(series,  item);    ,Double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getCloseYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)- 1;
increase failing tests, [FE] NullPointerException,   ,minimum = Math.max(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(includeInterval) { return Math.min(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(maximum > minimum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(includeInterval) { throw new IllegalArgumentException(""); }
compilation error,[CE] cannot find symbol maximal,   ,minimum = Math.min(minimum, maximal);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Math.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,[Delete]
compilation error,[CE] illegal start of type, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,}
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,==
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,>>
compilation error,[CE] 'else' without 'if', if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,{
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,>=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,!=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<=
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] ')' expected,   ,if(includeInterval && dataset instanceof IntervalXYDataset (dataset, dataset.getSeriesCount() > 0)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol NUMBER_INT, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NUMBER_INT || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData,   ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { return null; } else { DatasetUtilities.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { return null; } else { DatasetUtilities.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); [Delete]
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum) ||!Double.isNaN(lvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1.0;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Maximum, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Maximum.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum, uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >> 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() } 0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] incompatible types, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,return new NullPointerException("");
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] cannot find symbol size, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(size == 0) { throw new NullPointerException(""); }
compilation error,[CE] cannot find symbol max, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return new Range(minimum, max); }
compilation error,[CE] cannot find symbol size, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(size == 0) { throw new NullPointerException(""); } else { return new Range(minimum, maximum); }
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(" "); }
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Double.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
patch is same with buggy,, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds);
compilation error,[CE] non-static variable this cannot be referenced from a static context, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)this.dataset, iterateRangeBounds;
compilation error,[CE] cannot find symbol, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(ComparableXYDataset)dataset, iterateRangeBounds;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds + 1;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, includeInterval);
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds.length;
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; }
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } second = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Math.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NaN * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] 'else' without 'if',   ,while(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException(" "); }
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(includeInterval) { return this; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < throw new NullPointerException(" "); }
compilation error,[CE] ,   ,while(includeInterval) { return null; } else { throw new NullPointerException(" ");
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); [Delete]
increase failing tests, [FE] NullPointerException, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" ");!=
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(seriesCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(seriesCount)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Util.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(seriesCount)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY -(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY *(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY -(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Number.NEGATIVE_INFINITY - 1;
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.startYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLimitYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double m = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double j = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double r = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double y = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, max)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = (double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol,   ,triple maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol series,   ,int maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] cannot find symbol series,   ,int maximum = dataset.getMaximumYValue(series, 0);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval &&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] method getSeriesKey in interface SeriesDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesKey() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDataset() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol datasetCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < datasetCount; series++) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  >=  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue))) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)||(!Double.isNaN(uvalue))) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&(!Double.isNaN(uvalue))) {
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double yyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double j = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");!=
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >=
compilation error,[CE] generics are not supported in -source 1.4, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); <
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] method getSeriesKey in interface SeriesDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesKey() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDataset() == 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Number.NEGATIVE_INFINITY - 1;
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] illegal start of expression, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item+) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue <= 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue == 0.0) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > maximal) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] bad operand types for binary operator '>>', if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue >> 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() < 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= min) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimal) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
increase failing tests, [FE] AssertionFailedError,   ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return Math.min(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
increase failing tests, [FE] AssertionFailedError,   ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Maximum.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum, uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NumberInput,   ,double maximum = NumberInput.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 3;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY,   ,double maximum = Number.NEGATIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue < maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue >= maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue <= maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue>maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue < maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue >= maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue <= maximal) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >> 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() } 0) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE / 2;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initialiseXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.inc().setStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.inc().startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initialiseStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.validate(series, item);
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NeGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol Do, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Do.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Data.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY / 2.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.abs(Double.NEGATIVE_INFINITY)/ 2.0;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY)/ 2.0;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol NumberInclusive, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = NumberInclusive.doubleValue() / 2.0;
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] illegal start of expression, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item+) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == min) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,Float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] method getYValue in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getYValue(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series + 1);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(lvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY - 1;
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/> Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)*| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] method pow in class Math cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.pow(Double.MAX_VALUE);
compilation error,[CE] cannot find symbol max, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.max;
compilation error,[CE] variable maximum might not have been initialized, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.max(maximum, Integer.MAX_VALUE);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.max(maximum, dataset.getDomainBounds());
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.max(maximum, dataset.getDomainBounds());
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum, uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(interval)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
compilation error,[CE] method getSeriesKey in interface SeriesDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesKey() <= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset!= null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] NullPointerException, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] illegal start of type, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; }
compilation error,[CE] generics are not supported in -source 1.4, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; < double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; >= double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; == double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; >> double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol,   ,double l = ixyd.startYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLimitYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLongValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&& Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
patch is same with buggy,, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getInitialYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getInitialXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getSTARtYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLocale(series, item);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getItemCount(series, item);
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(5.0, 5.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.5, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.MAXIMUM_VALUE :(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer intervalXYDataset = dataset.getIntervalXYDataset();
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.MAXIMUM_VALUE :(double)Double.NON_GLOBAL_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.MAXIMUM_VALUE :(double)Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.MAXIMUM_VALUE :(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol series,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer intervalXYDataset = dataset.getItemCount(series);
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Data,   ,double maximum = Data.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol,   ,double maximum = DatasetUtilities.doubleValue(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 3;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY,   ,double maximum = Number.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1L;
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData,   ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(includeInterval) { return null; }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDataset()) { if(includeInterval) { return null; }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDataset()) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == maximum) { return null; }
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(includeInterval) { return this; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Math.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE * Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)*!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue,   ,ivalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lmin,   ,lmin = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartLocalValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] cannot find symbol gmin,   ,gmin = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Data,   ,double maximum = Data.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol Data,   ,double maximum = Data.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 2;
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");!=
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); <
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NeGATIVE_INFINITY + 1;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; &&
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; figured
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bodied
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bod
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; Alternatively
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; slated
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; meanwhile
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; Toujours
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; fulness
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.startYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = dataset.getYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getSize();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)*!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; < double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; >= double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; == double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol ivalue,   ,ivalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lmin,   ,lmin = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartLocalValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] cannot find symbol gmin,   ,gmin = intervalXYData.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&& Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum) || Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)||(uvalue > 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue <= 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue < 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)||(uvalue < 0.0)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] ')' expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum),!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xxyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.startXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  >=  maximum)  {    ,if(maximum >= min) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getDatasetCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesKey() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset!= null || dataset.getSeriesCount() == 0) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY | Double.MAX_VALUE;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum || minimum > maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum || minimum > maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum || minimum > maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || maximum > minimum) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initialiseXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.inc().setStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.inc().startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initialiseStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.validate(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");!=
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); <
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > maximal) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(maximum > 0.0) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > max) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValu
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series,
compilation error,[CE] 'else' without 'if', for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return maximum; }
compilation error,[CE] 'else' without 'if', for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return null; }
compilation error,[CE] 'else' without 'if', for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) {
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { max = Math.max(maximum,
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] no suitable method found for isInfinite(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(item!= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData == null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol IncludeInterval, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!IncludeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY % 2.0;
compilation error,[CE] no suitable method found for max(long),   ,double maximum = Math.max(Double.doubleToLongBits(maximum));
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NaN_INFINITY,   ,double maximum = Double.NaN_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2.0;
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue < 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(maximum > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue >= 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue>maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > max) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue <= 0.0) {
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Data.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Validate, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Validate.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Pair, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Pair.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = 0 * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue <= 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue == 0.0) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > maximal) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] bad operand types for binary operator '>>', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue >> 0.0) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,[Delete]
compilation error,[CE] illegal start of type, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,}
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,==
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,>>
compilation error,[CE] 'else' without 'if', if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,{
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,>=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,!=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,<=
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum << maximum) {
compilation error,[CE] ')' expected,   ,if(minimum [BUGGY] maximum) {
patch is same with buggy,, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol series, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSerialCount();
increase failing tests, [FE] IllegalArgumentException, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] method getSeriesCount in interface SeriesDataset cannot be applied to given types;, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount(0);
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue))) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)/(!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue))) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue))) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] bad operand types for binary operator '<<', if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum << maximum) {
compilation error,[CE] ')' expected, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum [BUGGY] maximum) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(seriesCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(seriesCount)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol datasetCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < datasetCount; series++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] no suitable method found for isInfinite(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] 'else' without 'if',   ,while(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException(" "); }
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(includeInterval) { return this; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else!= throw new NullPointerException(" "); }
compilation error,[CE] generics are not supported in -source 1.4,   ,if(includeInterval) { return null; } else < throw new NullPointerException(" "); }
compilation error,[CE] ,   ,while(includeInterval) { return null; } else { throw new NullPointerException(" ");
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NeGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue < 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Maximum.isNaN(uvalue)||(uvalue > 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)*| Double.isInfinite(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)*!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double yyd = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double j = ixyd.getStartYValue(series, item);
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double xx = ixyd.getStartYValue(series, item);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] ArrayIndexOutOfBoundsException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] illegal start of expression, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item+) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximal) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue == 0.0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue!= 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue <.5) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] method getSeriesKey in interface SeriesDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesKey() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDataset() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >> 0) {
compilation error,[CE] ')' expected,   ,if(dataset == null || dataset.getSeriesCount() } 0) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol INFINITY, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, max)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(itemCount)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, 0); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = Math.max(maximum, uvalue); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NumberInput, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = NumberInput.NEGATIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Number.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSequenceCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSingleDomainCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSerialCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRemainingCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRuleCount();
patch is same with buggy,, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] ClassCastException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] ClassCastException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesIndex() > 0) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getItemCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  >=  maximum)  {    ,if(maximum >= min) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(item!= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData == null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol IncludeInterval, intervalXYData.getStartXValue(series,  item);    ,if(!IncludeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValu
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return maximum; }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { max = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] cannot find symbol maximal, if(uvalue  >  0.0)  {    ,if(uvalue > maximal) {
increase failing tests, [FE] NullPointerException, if(uvalue  >  0.0)  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(uvalue  >  0.0)  {    ,if(maximum > 0.0) {
compilation error,[CE] cannot find symbol max, if(uvalue  >  0.0)  {    ,if(uvalue > max) {
increase failing tests, [FE]  double), if(uvalue  >  0.0)  {    ,if(uvalue <= 0.0) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getStartYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getStartYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); if(!Double.isNaN(series)) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if($Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol lower, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lower)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(10.0, 0.0);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(3.0, 0.0);
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum == maximum) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { maximum = Math.max(maximum,
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValu
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { lvalue = intervalXYData.getStartXValue(series, item); uvalue = intervalXYData.getEndXValue(series,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return maximum; }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(maximum)) { max = Math.max(maximum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(item!= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData == null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol IncludeInterval, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!IncludeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getStartYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getEndYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); lvalue = ixyd.getStartYValue(series,
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { double lvalue = ixyd.getEndYValue(series, 0); if(!Double.isNaN(series)) {
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-0);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-2);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] int cannot be dereferenced,   ,int itemCount = dataset.getItemCount(series-1).length;
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-3);
compilation error,[CE] cannot find symbol series0,   ,int itemCount = dataset.getItemCount(series0);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] variable uvalue is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double uvalue = dataset.getYValue(series, 0);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.POSITIVE_INFINITY);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.ERROR);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.MAX_VALUE);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.RESULT);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximal);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.NaN);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.NULL);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, false);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, range);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NaN * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.INFINITY * Double.NEGATIVE_INFINITY;
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getDatasetCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), false);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, true));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.expandDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset), true);
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset));
compilation error,[CE] no suitable method found for iterateDomainBounds(Range), return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateDomainBounds(dataset, true));
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] no suitable method found for iterateRangeBounds(XYDataset,double),   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, maximum); }
compilation error,[CE] cannot find symbol includesInterval,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includesInterval); }
compilation error,[CE] no suitable method found for iterateRangeBounds(XYDataset,double),   ,if(includeInterval) { return null; } else { DatasetUtilities.iterateRangeBounds(dataset, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol datasetUtilities,   ,if(includeInterval) { return null; } else { return datasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] cannot find symbol excludeInterval,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, excludeInterval); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset); }
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum) ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData,   ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { Double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { int minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double minimum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.NEGATIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) >> double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; [Delete]
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY;!=
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(maximum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/> Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return Math.min(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
increase failing tests, [FE] AssertionFailedError,   ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(includeInterval) { return null; }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDataset()) { if(includeInterval) { return null; }
increase failing tests, [FE]  double),   ,if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(includeInterval) { return this; }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = DatasetUtilities.includeInterval(this.dataset, dataset);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
increase failing tests, [FE] IllegalArgumentException,   ,if(includeInterval) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum || minimum > maximum) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,[Delete]
compilation error,[CE] illegal start of type, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,}
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<<
compilation error,[CE] 'else' without 'if', if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,{
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,==
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,>>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,>=
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,!=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<=
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, max)) {
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndYValue(series, item); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { double l = ixyd.getEndYValue(series, item); }
compilation error,[CE] variable lvalue is already defined in method iterateRangeBounds(XYDataset,boolean), double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double lvalue = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol l, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndXValue(series, item); }
compilation error,[CE] not a statement,   ,if(includeInterval) { double) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(minimum)|| Double.isInfinite(maximum)) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(minimum, maximum)|| Double.isInfinite(maximum)) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { Double.isNaN(minimum)|| Double.isInfinite(maximum)) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(minimum)|| Double.isInfinite(maximum)) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] ';' expected,   ,if(includeInterval) { for(Double.isNaN(minimum): Double.isNaN(maximum)) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(maximum)|| Double.isInfinite(minimum)) { return new Range(maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(maximum)|| Double.isInfinite(minimum)) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] not a statement,   ,if(includeInterval) { for(Double.isNaN(minimum)|| Double.isInfinite(maximum)) { return new Range(minimum); }
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Double.MIN_VALUE;
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] illegal start of expression, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item+) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSingleDomainCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSerialCount();
compilation error,[CE] cannot find symbol series, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount(series);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Data.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Validate, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Validate.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Pair, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Pair.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = 0 * Double.NEGATIVE_INFINITY;
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return this; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return Null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NeGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return this; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return Null; }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,[Delete]
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); [Delete]
compilation error,[CE] unreachable statement,   ,if(!includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" ");!=
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval, Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= min) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimal) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
compilation error,[CE] no suitable method found for isInfinite(double,double), if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum, uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol value, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(value)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(interval)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '<', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue < null &&!(uvalue instanceof Math.max))) {
compilation error,[CE] bad operand types for binary operator '<', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue < null &&!(uvalue instanceof XYDataset))) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximal) {
compilation error,[CE] no suitable method found for max(double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.max(maximum)) {
compilation error,[CE] bad operand types for binary operator '<', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue < null &&!(uvalue instanceof Math.maximum))) {
compilation error,[CE] bad operand types for binary operator '<', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue < null &&!(uvalue instanceof Maximum))) {
compilation error,[CE] bad operand type double for unary operator '!', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.max(maximum, uvalue)) {
compilation error,[CE] ')' expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!(uvalue < null &&!(uvalue instanceof Math.max), max)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getDatasetCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY - Double.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item!= itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount.length; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] ';' expected,   ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item >> itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 1; item!= itemCount; item++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol lower, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(lower)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(minimum)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(itemCount)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, 0); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = Math.max(maximum, uvalue); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.001, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.5, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(5.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] incompatible types,   ,Double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(series); for(int series = 0; series < seriesCount; series++) {
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(itemCount)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { int itemCount = dataset.getItemCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, u
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = intervalXYData.getEndXValue(series, 0); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); uvalue = Math.max(maximum, uvalue); }
compilation error,[CE] ';' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, uvalue); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getMeanXValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getStartItem(series, item);
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&& Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NumberInput,   ,double maximum = NumberInput.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 3;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY,   ,double maximum = Number.NEGATIVE_INFINITY - 1;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Data.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Data.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = 0 * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] method getXValue in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getXValue(series);
compilation error,[CE] incompatible types,   ,Float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] int cannot be dereferenced,   ,float itemCount = dataset.getItemCount(series).doubleValue();
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series + 1);
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndYValue(series, item); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { double l = ixyd.getEndYValue(series, item); }
compilation error,[CE] variable lvalue is already defined in method iterateRangeBounds(XYDataset,boolean), double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double lvalue = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol l, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndXValue(series, item); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( "Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] ,   ,boolean includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName());
compilation error,[CE] ,   ,boolean includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Unknown variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else >> throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else [Delete] throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); [Delete]
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,[Delete]
compilation error,[CE] illegal start of type, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,}
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<<
compilation error,[CE] 'else' without 'if', if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,{
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,==
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,>>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,>=
compilation error,[CE] generics are not supported in -source 1.4, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,!=
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,<=
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum << maximum) {
compilation error,[CE] ')' expected,   ,if(minimum [BUGGY] maximum) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Data.NEGATIVE_INFINITY / 2;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY);
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); [Delete]
increase failing tests, [FE] NullPointerException, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); >>
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" ");!=
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException( ""); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, return  new  Range(minimum,  maximum);    ,return new Range(minimum, maximum);
compilation error,[CE] missing return statement, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] missing return statement, return  new  Range(minimum,  maximum);    ,if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(includeInterval); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(maximum); }
compilation error,[CE] cannot find symbol, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { addInterval(includeInterval); }
compilation error,[CE] cannot find symbol maximal, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximal); }
compilation error,[CE] cannot find symbol, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { throw new IllegalFieldValueException(""); }
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/> Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)*| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum == maximum) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(5.0, 5.0);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 3;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1L;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 4;
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,[Delete]
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Toujours
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); [Delete]
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); >>
compilation error,[CE] cannot find symbol includesInterval, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includesInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Afterward
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval);!=
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Alternatively
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum << maximum) {
compilation error,[CE] ')' expected,   ,if(minimum [BUGGY] maximum) {
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getMeanYValue(series, item);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double i = ixyd.getItemCount(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLocale(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&& Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol interval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(interval)) {
compilation error,[CE] no suitable method found for isNaN(boolean), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(includeInterval)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return this; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return Null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NeGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return this; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return Null; }
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol datasetCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < datasetCount; series++) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] ')' expected,   ,if(!Double.isNaN(maximum),!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ivalue,   ,ivalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRangeValue(series, item);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 3;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 0.5;
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = DatasetUtilities.createDataset(dataset, iterateRangeBounds);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getStartYValue(series, item);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = DatasetUtilities.getDataset(dataset, iterateRangeBounds);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.clone();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getXYRangeBounds();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getStartYValue(series, 0);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = getRangeDataset();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Long.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } second = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Math.POSITIVE_INFINITY + Integer.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY? Double.MAXIMUM_VALUE : Double.MAXIMUM_VALUE;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY? Double.MAX_VALUE : Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY? Double.MAX_VALUE : Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double yyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double j = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] incompatible types,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] incompatible types,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndYValue(series, item); }
compilation error,[CE] variable lvalue is already defined in method iterateRangeBounds(XYDataset,boolean),   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double lvalue = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol l,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getEndYValue(series, item); }
compilation error,[CE] incompatible types,   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getEndXValue(series, item); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - 1; triple maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Data,   ,double maximum = Data.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol,   ,double maximum = DatasetUtilities.doubleValue(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] bad operand types for binary operator '|',   ,double maximum = Double.NEGATIVE_INFINITY | Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { return null; } else { DatasetUtilities.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { return null; } else { DatasetUtilities.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); [Delete]
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum, uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(minimum, lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Data.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Data.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" ");
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( " ");
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException(" "); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,throw new NullPointerException(" ");[] if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol max,   ,if(includeInterval) { throw new NullPointerException(" "); } else { return new Range(minimum, max); }
compilation error,[CE] cannot find symbol maximal,   ,if(includeInterval) { throw new NullPointerException(" "); } else { return new Range(minimum, maximal); }
compilation error,[CE] cannot find symbol max,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, max); }
compilation error,[CE] cannot find symbol Preconditions,   ,throw new NullPointerException(" ");Preconditions.checkNotNull(minimum, maximum);
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum!= maximum) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] bad operand types for binary operator '<<', if(minimum  >=  maximum)  {    ,if(minimum << maximum) {
compilation error,[CE] ')' expected, if(minimum  >=  maximum)  {    ,if(minimum [BUGGY] maximum) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] illegal start of type,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } second = Double.NEGATIVE_INFINITY; }
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Math.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] non-static variable this cannot be referenced from a static context, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < this.seriesCount; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol listCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < listCount; series++) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, max)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NaN * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(double.isNaN(uvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] int cannot be dereferenced, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount.length; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item { itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item!= itemCount; item++) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NeGATIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
patch is same with buggy,, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getInitialYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLeafYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLocale(series, item);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getItemCount(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getIntervalYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).doubleValue();
increase failing tests, [FE]  Size, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double max = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Data.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol Data, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Data.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = 0 * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol gvalue,   ,gvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ivalue,   ,ivalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRangeValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NaN || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)||!Double.isNaN(minimum)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY *(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval, Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] double cannot be dereferenced, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item).getValue();
compilation error,[CE] cannot find symbol periodXYData, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getSTARtXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol durationXYData, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = durationXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getBeginXValue(series, item);
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(double)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY,   ,double minimum = Integer.POSITIVE_INFINITY + Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Long.MAX_VALUE;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum, lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol,   ,double l = ixyd.startYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLimitYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLongValue(series, item);
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, true);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.expandDomainBounds(dataset, false);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,Range dataset = DatasetUtilities.findDomainBounds(dataset, false);
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).doubleValue();
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.NEGATIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Double.MAX_VALUE;
compilation error,[CE] cannot find symbol NEGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Integer.NEGATIVE_INFINITY + Double.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(3.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.5, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.001, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.75, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NaN * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected,   ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY* Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol INFINITY,   ,double maximum = Double.INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!Double.isNaN(lvalue)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] incompatible types, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData.getStartXValue(series, item)) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(item!= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData == null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol IncludeInterval, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!IncludeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol mappingMaximum, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(mappingMaximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] '.class' expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(double)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum)||!Double.isNaN(uvalue)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(minimum, lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval) {
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; bodied else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; hopped else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; toured else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; meanwhile else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; delt else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; starred else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; figured else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Integer.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Feature, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_NON_NULL_OBJECT)) {
compilation error,[CE] cannot find symbol Feature, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_NON_NUMERIC_NULL_ERROR)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Uvalue.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Positive_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Positive_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ohlc.getValue())) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChangeEvent(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChild(series, item);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double i = ixyd.getItemCount(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { ixyd.setYValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getStartYValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double uvalue = ixyd.getYValue(series, item); if(!Double.isNaN(
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNa
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
increase failing tests, [FE] AssertionFailedError,   ,minimum = Math.max(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(minimum < null) { if(maximum > minimum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) { if(minimum > maximum) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum < null) { if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) { if(minimum > maximum) { return new Range(minimum, null); }
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) { if(minimum < null) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) { if(minimum > minimum) { return new Range(minimum, maximum); }
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY + 1;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY + 1;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() >= 0) {
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] 'else' without 'if', double  xyd  =  ixyd.getStartYValue(series,  item);    ,if(xyd!= null) { double xyd = ixyd.getEndXValue(series, item); if(!Double.isNaN(xyd)) { minimum = Math.min(minimum, xyd); }
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] 'else' without 'if', double  xyd  =  ixyd.getStartYValue(series,  item);    ,if(xyd!= null) { double xyd = ixyd.getEndXValue(series, item); if(xyd == null) { xyd = ixyd.getEndYValue(series, item); }
compilation error,[CE] 'else' without 'if', double  xyd  =  ixyd.getStartYValue(series,  item);    ,if(xyd!= null) { double xyd = ixyd.getEndXValue(series, item); if(xyd > 0.0) { xyd = ixyd.getLastYValue(series, item); }
compilation error,[CE] 'else' without 'if', double  xyd  =  ixyd.getStartYValue(series,  item);    ,if(xyd!= null) { double xyd = ixyd.getEndXValue(series, item); if(!Double.isNaN(xyd)) { return Math.min(xyd, xyd); }
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximal) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > max) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > MAX_VALUE) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > absolute) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue >= maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > threshold) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > minimum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maxim) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > threshold) {
compilation error,[CE] illegal start of expression,   ,if(minimum > minimum || minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > limit) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < upperBounds) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum > range.length) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < upperBoundVal) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum || minimum > threshold) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum || minimum > maximum) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double datasetCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol series,   ,double datasetCount = dataset.getDatasetCount(series);
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSequenceCount();
compilation error,[CE] cannot find symbol,   ,double datasetCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondSize();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondState();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol series,   ,double datasetCount = dataset.getDatasetCount(series);
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol roundCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 3;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE / Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE - 1;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] generics are not supported in -source 1.4, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) <
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double minimum = Double.NEGATIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getRangeCount(); if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(seriesCount > 1) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getRangeCount(); if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximal = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) >> double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; >>
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; [Delete]
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY; int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isLiteralValue(dataset)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isExpressionNode(dataset)) {
compilation error,[CE] cannot find symbol DatasetUtils, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtils.isExpressionNode(dataset)) {
compilation error,[CE] cannot find symbol DatasetUtils, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtils.isLiteralValue(dataset)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(uvalue > 0.0 ||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY; int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY; Integer period = dataset.getRangeCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Range,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { return Range; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(); }
compilation error,[CE] inconvertible types,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] not a statement,   ,if(includeInterval && dataset instanceof IntervalXYDataset) { (( IntervalXYDataset)dataset).getSeriesCount() > 0) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).getValue();
increase failing tests, [FE]  Size, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] cannot find symbol item, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, item);
compilation error,[CE] incompatible types, float  itemCount  =  dataset.getItemCount(series);    ,boolean itemCount = dataset.getItemCount(series);
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] variable maximum might not have been initialized, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.max(maximum, Integer.MAX_VALUE);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * 2);
compilation error,[CE] cannot find symbol lvalue, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + lvalue;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.isInfinite(series, item));
compilation error,[CE] method pow in class Math cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.MAX_VALUE);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 || uvalue!= Integer.MAX_VALUE) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isLiteralValue(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isMultiply(dataset)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 || uvalue instanceof Double) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isLiteralValue(dataset)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isGlobal(dataset)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > 0.0 ||!Util.isLiteralValue(series, item)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Integer.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum might not have been initialized, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.max(maximum, Integer.MAX_VALUE);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] method doubleToLongBits in class Double cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.pow(Double.doubleToLongBits(dataset));
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.pow(Double.isInfinite(series, item));
compilation error,[CE] no suitable method found for toString(XYDataset), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.pow(Double.toString(dataset));
compilation error,[CE] method pow in class Math cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2 * Math.pow(Double.MAX_VALUE);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol pvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,pvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] cannot find symbol mvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,nvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] cannot find symbol pvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,pvalue = intervalXYData.getPosition(series, item);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series-1);
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item >= 0) { int itemCount = dataset.getItemCount(series-1); if(item < 0 || item > 0) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item == 0) { int itemCount = dataset.getItemCount(series-1); if(item < 0 || item > 0) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item < 0) { int itemCount = dataset.getItemCount(series-1); if(item == 0 || item > 0) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item < 0) { int itemCount = dataset.getItemCount(series-1); }
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item < 0) { int itemCount = dataset.getItemCount(series-1); if(item == 0) { minimum = Math.min(minimum, itemCount); }
compilation error,[CE] illegal start of expression,   ,for(int item = dataset.getItemCount(series-1); if(item >= 0) { int itemCount = dataset.getItemCount(series-1); if(item < 0) { minimum = Math.min(minimum, itemCount); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] non-static method isNaN() cannot be referenced from a static context, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN()? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN(value)|| Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] method toHexString in class Integer cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY + Integer.toHexString(includeInterval)* Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol value, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN(value)|| Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series));
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Integer.MAX_VALUE);
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NegativeInfinition, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NegativeInfinition + Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < Series.END_ARRAY; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < caseCount; item++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol series,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5;
compilation error,[CE] incompatible types,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.toString(dataset.getSeriesCount());
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Range,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { return Range; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(); }
compilation error,[CE] inconvertible types,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLocale(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getFirstYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLimit(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getstartYValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(seriesCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDomainBounds() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getItemCount() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() >= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() > 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum)!=
compilation error,[CE] generics are not supported in -source 1.4, if(minimum  >=  maximum)  {    ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression, if(minimum  >=  maximum)  {    ,if(minimum == maximum) >=
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2 + 1;
compilation error,[CE] ';' expected,   ,double maximum = Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] ';' expected,   ,double maximum = Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 3;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double y = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double r = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double u = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double r = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double h = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double u = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double d = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double p = ixyd.getStartXValue(series, item);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE / Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE - 1;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLeftYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLowerBound(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getLastChangeEvent(series, item);
patch is same with buggy,, double  i  =  ixyd.getStartXValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isInfinite(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] cannot find symbol item,   ,float itemCount = dataset.getYValue(series, item);
compilation error,[CE] incompatible types,   ,Float itemCount = dataset.getItemCount(series);
compilation error,[CE] method getYValue in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getYValue(series);
compilation error,[CE] method getSeriesCount in interface SeriesDataset cannot be applied to given types;,   ,float itemCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series);
compilation error,[CE] cannot find symbol item,   ,double itemCount = dataset.getYValue(series, item);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getPosition(series, item);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 3;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&& double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.max(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, minimum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximal);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.ERROR);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, minimal);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, 0);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximum + 1);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.ISSUE);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.RANGE);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,float rangeCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getYSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getSecondsCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.getIntervalBounds();
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable lvalue might not have been initialized, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getEndXValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,int itemCount = intervalXYData.getItemCount(series);
compilation error,[CE] cannot find symbol, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(getItemCount(series) > 1) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean), for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(dataset!= null) { return null; }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum >= maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= min) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol count, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < count; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol columnCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < columnCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum >= maximum || maximum > range) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue))) {
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = domainXYData.getStartXValue(series, item);
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,l value = intervalXYData.getStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(lvalue >= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { return null; }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, range); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, seriesCount); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData,   ,lvalue = domainXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)&&!Double.isNaN(lvalue)) {
patch is same with buggy,, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds;
compilation error,[CE] <identifier> expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, this.iterateRangeBounds;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds);
compilation error,[CE] variable series is already defined in method iterateRangeBounds(XYDataset,boolean), IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, series;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, iterateRangeBounds + 1;
compilation error,[CE] ';' expected, IntervalXYDataset  ixyd  =(IntervalXYDataset)dataset,  iterateRangeBounds;    ,IntervalXYDataset ixyd =(IntervalXYDataset)dataset, fieldUtils.safeMultiply(this.range);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY; int seriesCount = dataset.getRowCount();
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 2;
compilation error,[CE] cannot find symbol lvalue,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + lvalue;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Uvalue.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol maximal,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(minimum, maximal); }
increase failing tests, [FE] NullPointerException,   ,if(includeInterval) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum >= maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] cannot find symbol mvalue,   ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getPosition(series, item);
compilation error,[CE] missing return statement, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] missing return statement, return  new  Range(minimum,  maximum);    ,if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  new  Range(minimum,  maximum);    ,if(this.includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol, return  new  Range(minimum,  maximum);    ,if(includeInterval()) { return new Range(minimum, maximum); }
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  new  Range(minimum,  maximum);    ,if(this.minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;, return  new  Range(minimum,  maximum);    ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(maximum, null); }
compilation error,[CE] cannot find symbol intervalInterval, return  new  Range(minimum,  maximum);    ,if(intervalInterval) { return new Range(minimum, maximum); }
patch is same with buggy,, return  new  Range(minimum,  maximum);    ,return new Range(minimum, maximum);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >=  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,int seriesCount = dataset.getRangeCount(); if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bodied
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(!includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] not a statement, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; bodied
compilation error,[CE] generics are not supported in -source 1.4, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) < double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) } double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; >>
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument."); }
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException( "Null 'dataset' argument. "); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 || uvalue!= Integer.MAX_VALUE) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isLiteralValue(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isMultiply(dataset)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 || uvalue instanceof Double) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isLiteralValue(dataset)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!DatasetUtilities.isGlobal(dataset)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!Util.isLiteralValue(series, item)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; &&!System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; delt else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; delt else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSingleDomainCount();
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSecondLevelCount();
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSecondSize();
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum >= min) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] method getXValue in interface XYDataset cannot be applied to given types;,   ,float itemCount = dataset.getXValue(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,Float itemCount = dataset.getItemCount(series);
compilation error,[CE] cannot find symbol item,   ,float itemCount = dataset.getXValue(series, item);
compilation error,[CE] method getSeriesCount in interface SeriesDataset cannot be applied to given types;,   ,float itemCount = dataset.getSeriesCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float itemCount = dataset.getColumnCount(series);
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.NEGATIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol Negative_INFINITY, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.Negative_INFINITY) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.max(2.0, 0.0);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double max = Math.max(2.0, 0.0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Math.min(2.0, 0.0);
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Math.max(2.0, 0.0);
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
increase failing tests, [FE] NullPointerException, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,if(minimum == Double.NEGATIVE_INFINITY) { minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; figured
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Frequently
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; delt
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; toured else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; figured else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; && fiance else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() >= 0) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ohlc, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc.getValue())) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximal = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY; int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY; Integer period = dataset.getRangeCount();
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { ixyd.setYValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getStartYValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double uvalue = ixyd.getYValue(series, item); if(!Double.isNaN(
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNa
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc.getValue())) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 || uvalue!= 1.0) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > max) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!Util.isLiteralValue(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 || uvalue!=.maximum) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > 0.0 ||!Util.isLiteralValue(series)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData,   ,lvalue = domainXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; &&!System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; delt else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol count, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < count; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol columnCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < columnCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,XYDataset ixyd = getDataset(series);
compilation error,[CE] cannot find symbol, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { ixyd.setYValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of type, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getStartYValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] '.class' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double uvalue = ixyd.getYValue(series, item); if(!Double.isNaN(
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNa
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDomainBounds() == 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getItemCount() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Integer.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum >= maximum || maximum > range) {
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLeftYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getWeeksInYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getDecimalYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getDoubleYValue(series, item);
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { return null; } if(includeInterval) { return NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Uvalue.isNaN(uvalue)||!Double.isNaN(itemCount)) {
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
increase failing tests, [FE] AssertionFailedError, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, 0);
compilation error,[CE] incompatible types, float  itemCount  =  dataset.getItemCount(series);    ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).getValue();
increase failing tests, [FE]  Size, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
compilation error,[CE] method getXValue in interface XYDataset cannot be applied to given types;, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getXValue(series);
compilation error,[CE] cannot find symbol,   ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] variable lvalue is already defined in method iterateDomainBounds(XYDataset,boolean),   ,long lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable lvalue is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] illegal start of expression,   ,= intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.setBaseValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.resetStartXValue(series, item);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable maximum might not have been initialized, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.max(maximum, Integer.MAX_VALUE);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * 2);
compilation error,[CE] cannot find symbol lvalue, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + lvalue;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.isInfinite(series, item));
compilation error,[CE] method pow in class Math cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * 2 + Math.pow(Double.MAX_VALUE);
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY), rehashTable(); if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.NEGATIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol ohlc, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ohlc.getValue())) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY - 1;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ohlc, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc.getValue())) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Math.max(0.0, 0.0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double max = Math.max(0.0, 0.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Math.min(0.0, 0.0);
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol roundCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return null; }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(dataset, minimum, maximum); }
compilation error,[CE] cannot find symbol excludeInterval,   ,if(includeInterval) { return null; } if(includeInterval) { return DatasetUtilities.iterateRangeBounds(dataset, excludeInterval); }
compilation error,[CE] cannot find symbol minum,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(dataset, minum, maximum); }
compilation error,[CE] cannot find symbol includesInterval,   ,if(includeInterval) { return null; } if(includeInterval) { return DatasetUtilities.iterateRangeBounds(dataset, includesInterval); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(dataset, maximum); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(dataset, includeInterval); }
compilation error,[CE] cannot find symbol excludeInterval,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(dataset, excludeInterval); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Integer.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Feature, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_NON_NULL_OBJECT)) {
compilation error,[CE] cannot find symbol Feature, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_NON_NUMERIC_NULL_ERROR)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(peekValue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Math.max(Double.NEGATIVE_INFINITY, Integer.MAX_VALUE);
compilation error,[CE] incompatible types,   ,Double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NegativeInfinition,   ,double maximum = Double.NegativeInfinition + Integer.MAX_VALUE;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] non-static method isNaN() cannot be referenced from a static context, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN()? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN(value)|| Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] method toHexString in class Integer cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY + Integer.toHexString(includeInterval)* Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol value, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isNaN(value)|| Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series));
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Range,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { return Range; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(); }
compilation error,[CE] inconvertible types,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY || Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY)/(Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
patch is same with buggy,, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getLeftYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getDecimalYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartXValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
compilation error,[CE] cannot find symbol roundCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundCount; series++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rangeCount; series++) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; toured else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; figured else { return new Range(minimum, maximum); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] 'else' without 'if', if(includeInterval)  {  return  null;  }  else  {  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return new Range(minimum, maximum);
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() == 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() == 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Uvalue.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double :(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double -(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double :(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double :(double)Double.NEGATIVE_INFINITY : Integer.MAX_VALUE;
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double -(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] cannot find symbol doubleValue, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY || Double.doubleValue =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] '.class' expected, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.NEGATIVE_INFINITY? double :(double)Double.NEGATIVE_INFINITY : Single.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(dataset instanceof Range) { dataset =(RelativeXYDataset)dataset.getBaseValue(series, item); }
compilation error,[CE] cannot find symbol series, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] incompatible types, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,Double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; }
compilation error,[CE] inconvertible types, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] inconvertible types, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; } if(dataset instanceof Range) { dataset =(Dataset)dataset.getSeriesCount(); }
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol NEGATING_INFINITY, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double datasetCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol series,   ,double datasetCount = dataset.getDatasetCount(series);
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSequenceCount();
compilation error,[CE] cannot find symbol,   ,double datasetCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondSize();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getSecondState();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getDatasetCount();
compilation error,[CE] cannot find symbol series,   ,double datasetCount = dataset.getDatasetCount(series);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum)!=
compilation error,[CE] generics are not supported in -source 1.4,   ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) >=
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof HorizonXYDataset) { dataset =(JavaXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series,
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getBaseValue(series, item); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] generics are not supported in -source 1.4,   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) <
patch is same with buggy,, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset!= null) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval();
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset!= null) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(!getMask()) { return null; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(!getMask()) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() >= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() > 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)||(uvalue > 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue <= 0.0)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&(uvalue < 0.0)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)||(uvalue >= 0.0)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() == 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] NullPointerException,   ,if(dataset == null || dataset.getSeriesCount() == 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() == 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); [Delete]
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); >>
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLocale(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getFirstYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getStartLimit(series, item);
compilation error,[CE] cannot find symbol,   ,double l = ixyd.getstartYValue(series, item);
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; hopped else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; bodied else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; meanwhile else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; figured else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; slated else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; toured else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); bodied
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); Alternatively
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; >> else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] cannot find symbol includeXYDataset, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeXYDataset && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset instanceof IntervalXYDataset) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx =(ixyd == null)? xx : ixyd.getXValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getStartYValue(series, item);
compilation error,[CE] incompatible types, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);Double y = ixyd.getYValue(series, item);
compilation error,[CE] variable xx is already defined in method iterateRangeBounds(XYDataset,boolean), double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item); Double xx = ixyd.getEndXValue(series, item);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY; Double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol series,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer interval = dataset.getItemCount(series, item);
compilation error,[CE] cannot find symbol series,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer interval = dataset.getEndYValue(series, item);
compilation error,[CE] cannot find symbol series,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer period = dataset.getEndYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDomainBounds() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getItemCount() == 0) {
compilation error,[CE] cannot find symbol, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getDatasetCount() == 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
patch is same with buggy,, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getxValue(series, item);
compilation error,[CE] double cannot be dereferenced, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item).doubleValue();
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getChronology(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)- 1;
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol lvalue, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  xx  =  ixyd.getXValue(series,  item);    ,double xx = ixyd.setXValue(series, item);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(3.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.5, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.1, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.001, Double.NEGATIVE_INFINITY);
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; bodied else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; hopped else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; bodied else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; hopped else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; delt else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; meanwhile else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; meanwhile else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] not a statement,   ,if(includeInterval) { return null; delt else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol lvalue, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + lvalue;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof HorizonXYDataset) { dataset =(JavaXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series,
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getBaseValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(lvalue >= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { return null; }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getRowCount();
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() - 1;
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() + 1;
increase failing tests, [FE] NullPointerException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSingleDomainCount();
increase failing tests, [FE] IllegalArgumentException, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSeriesCount() * 2;
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSecondLevelCount();
compilation error,[CE] cannot find symbol, double  seriesCount  =  dataset.getSeriesCount();    ,double seriesCount = dataset.getSecondSize();
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY + 1;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum << Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY / 2;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
patch is same with buggy,, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLeftYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLowerBound(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getWeeksInYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLastChangeEvent(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getBeginYValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChangeEvent(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChangeGap(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChange(series, item);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,double i = ixyd.getItemCount(series, item);
compilation error,[CE] cannot find symbol,   ,double i = ixyd.getLastChild();
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum ||!Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Uvalue.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(uvalue)*|(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue >= 0.0)) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getEndXValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = intervalXYData.getItemCount(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(getItemCount(series) > 1) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(dataset!= null) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
increase failing tests, [FE]  double), minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,if(minimum == Double.NEGATIVE_INFINITY) { minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; figured
compilation error,[CE] unreachable statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null;
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; Frequently
compilation error,[CE] not a statement, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; delt
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol count, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < count; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol columnCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < columnCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, range); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, seriesCount); }
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] not a statement,   ,(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.getItemCount() >(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY); >>
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLocale(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getBeginYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getFirstYValue(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLongValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item)- 1;
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartLimit(series, item);
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getstartYValue(series, item);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series);
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = this.dataset.getSeries(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getSeries(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeriesKey(series);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(lvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol series,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5;
compilation error,[CE] incompatible types,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.toString(dataset.getSeriesCount());
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] AssertionFailedError,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.Negative_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(!includeInterval) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE]  double), if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(lvalue >= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { return null; }
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol intValue, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.toHexString(intValue);
compilation error,[CE] incompatible types, double  minimum  =  Double.POSITIVE_INFINITY  *  Double.POSITIVE_INFINITY;    ,double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.toString(dataset.getSeriesCount());
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE / Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] generics are not supported in -source 1.4, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) <
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY | Double.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY ET Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NegativeInfinition, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NegativeInfinition + Integer.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getSeriesCount();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getItemCount(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset =(XYDataset)getDataset(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset =(XYDataset)getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getSeriesKey(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getDataset(series);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)dataset.getSeries(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)getDataset(dataset);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] not a statement,   ,if(includeInterval && dataset instanceof IntervalXYDataset) { (( IntervalXYDataset)dataset).getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Range,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { return Range; }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(); }
compilation error,[CE] inconvertible types,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE / Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Double.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE - 1;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum < Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= Double.POSITIVE_INFINITY || maximum > Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series);
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = this.dataset.getSeries(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getSeries(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeriesKey(series);
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >=  maximum)  {    ,if(minimum >= maximum || maximum > range) {
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData,   ,lvalue = domainXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol series, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof HorizonXYDataset) { dataset =(JavaXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol series, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol series, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] '.class' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series,
compilation error,[CE] cannot find symbol series, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getBaseValue(series, item); }
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 4;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum >= minimum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum >= maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum >= min) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] ClassCastException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 1) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset instanceof IntervalXYDataset) {
compilation error,[CE] ')' expected, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(includeInterval || dataset instanceof IntervalXYDataset, dataset.getSeriesCount() > 0) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval  &&  dataset  instanceof  IntervalXYDataset  &&  dataset.getSeriesCount()  >  0)  {    ,if(this.intervalXYDataset instanceof IntervalXYDataset && dataset instanceof IntervalXYDataset || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(this.minimum > maximum) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,if(includeInterval) { for(XYDataset dataset : getDatasets()) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return new Range(minimum, maximum); } else { return new Range(maximum, minimum); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,if(includeInterval) { for(XYDataset dataset : getDatasets()) { return new Range(minimum, minimum); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() >= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() > 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException,   ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(minimum == Double.Negative_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) { if(!includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | 1;
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol min, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum == min) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol startCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < startCount; series++) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE / Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE - 1;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE, Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol BigDecimal,   ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MAX_VALUE;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, 1.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(3.0, 3.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.min(0.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.1, 0.0);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, 1.0);
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { throw new NullPointerException(""); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(lvalue >= 0) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { return null; }
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { ixyd.setYValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = ixyd.getStartYValue(series, item);
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getStartYValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double uvalue = ixyd.getYValue(series, item); if(!Double.isNaN(
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNa
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double ixyd = ixyd.getXValue(series, item); double lvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { Double ixyd = ixyd.getXValue(series, item); double xyd = ixyd.getYValue(series, item); if(!Double.isNaN
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRangeCount();
patch is same with buggy,, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRowCount();
compilation error,[CE] incompatible types, float  seriesCount  =  dataset.getSeriesCount();    ,boolean seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] IllegalArgumentException, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] possible loss of precision, float  seriesCount  =  dataset.getSeriesCount();    ,char seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] ,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - 1; if(double maximum == Double.NEGATIVE_INFINITY) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; for(int i = 0; i < dataset.getItemCount(); i++) { throw new IllegalArgumentException(""); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY - 1; for(int i = 0; i < dataset.getItemCount(); i++) { throw new IllegalArgumentException(""); }
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol startCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < startCount; series++) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY + 1;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double minimum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 4;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 10;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData,   ,lvalue = domainXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.resetStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.expectStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.skipEndXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.incidentallyDefineXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.selectXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.incidentallySet(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol ovalue,   ,ovalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol pvalue,   ,pvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol nvalue,   ,nvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol jvalue,   ,jvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol bvalue,   ,bvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item));
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series));
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
compilation error,[CE] ')' expected,   ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Positive_INFINITY,   ,double maximum = Double.Positive_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum =(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol,   ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] variable lvalue is already defined in method iterateDomainBounds(XYDataset,boolean),   ,long lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable lvalue is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] illegal start of expression,   ,= intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.setBaseValue(series, item);
compilation error,[CE] cannot find symbol,   ,intervalXYData.resetStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MIN_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE, Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol BigDecimal, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + BigDecimal.MIN_VALUE;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 4;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 10;
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; bodied else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; hopped else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; toured else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; meanwhile else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; delt else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; starred else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; figured else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; bodied else { throw new NullPointerException( " "); }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.MAX_VALUE;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : (double)Double.NEGATIVE_INFINITY;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Integer.MAX_VALUE;
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.valueOf(getMeanValue(series, item));
compilation error,[CE] cannot find symbol,   ,double maximum =(double)Double.NEGATIVE_INFINITY; Integer seriesCount = dataset.getRowCount();
compilation error,[CE] incompatible types,   ,double maximum =(double)Double.NEGATIVE_INFINITY?(double)Double.NEGATIVE_INFINITY : Double.valueOf(maximum);
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] generics are not supported in -source 1.4, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) <
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" ");
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( " ");
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" "); if(includeInterval) { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( " "); if(includeInterval) { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( "");
compilation error,[CE] unreachable statement,   ,throw new NullPointerException( " "); if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, maximum, null); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, maximum, true); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;,   ,throw new NullPointerException(" "); if(includeInterval) { return new Range(minimum, maximum, false); }
compilation error,[CE] cannot find symbol maximal, if(uvalue  >  0.0)  {    ,if(uvalue > maximal) {
compilation error,[CE] cannot find symbol max, if(uvalue  >  0.0)  {    ,if(uvalue > max) {
increase failing tests, [FE] AssertionFailedError, if(uvalue  >  0.0)  {    ,if(uvalue > 0.0 || uvalue!= 1.0) {
compilation error,[CE] cannot find symbol MAX_VALUE, if(uvalue  >  0.0)  {    ,if(uvalue > MAX_VALUE || uvalue > 0.0) {
compilation error,[CE] cannot find symbol MAX_VALUE, if(uvalue  >  0.0)  {    ,if(uvalue > MAX_VALUE) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Uvalue.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isInfinite(uvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue instanceof Number ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] generics are not supported in -source 1.4, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) <
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] cannot find symbol END_ARRAY, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < Series.END_ARRAY; item++) {
compilation error,[CE] cannot find symbol caseCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < caseCount; item++) {
compilation error,[CE] bad operand type double for unary operator '!', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.max(maximum, uvalue)) {
compilation error,[CE] cannot find symbol maximal, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximal) {
compilation error,[CE] bad operand type double for unary operator '!', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.max(maximum, uvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum || lvalue > uvalue.length) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.max(maximum, uvalue));
compilation error,[CE] bad operand type double for unary operator '!', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.abs(uvalue)> data.length) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > max) {
compilation error,[CE] method exp in class Math cannot be applied to given types;, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue > maximum ||!Math.exp(uvalue, 0.0)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof HorizonXYDataset) { dataset =(JavaXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { dataset =(RelativeXYDataset)dataset.getBaseValue(series, item); }
compilation error,[CE] ';' expected,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(minimum = Double.POSITIVE_INFINITY) { minimum = Double.POSITIVE_INFINITY + Integer.MIN_VAL
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] no suitable method found for max(double),   ,double maximum = Math.max(Double.NEGATIVE_INFINITY / 2.0);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] incompatible types,   ,Double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] ')' expected,   ,double maximum = Math.max(Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2.0;
compilation error,[CE] cannot find symbol,   ,double maximum = DatasetUtilities.doubleValue(dataset);
compilation error,[CE] method doubleToLongBits in class Double cannot be applied to given types;,   ,double maximum = Math.max(Double.doubleToLongBits(dataset));
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset!= null) { if(includeInterval) { return null; }
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset == null) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset!= null) { if(includeInterval) { return new Range(minimum, maximum); }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval();
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY (Integer.MAX_VALUE);
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  Integer.MAX_VALUE;    ,double minimum = Integer.POSITIVE_INFINITY - Double.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), if(minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maxim, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maxim == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
compilation error,[CE] ')' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval | Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY | Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY || Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY)/(Double.POSITIVE_INFINITY);
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum >= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimal) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(maximum == min) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getEndXValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = intervalXYData.getItemCount(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(getItemCount(series) > 1) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(dataset!= null) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] incompatible types,   ,Double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Math.max(0.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.00, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ohlc, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc.getValue())) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximal) {
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) }
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) >>
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) <<
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) [Delete]
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum)!=
compilation error,[CE] generics are not supported in -source 1.4, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) <
compilation error,[CE] illegal start of expression, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum == maximum) >=
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getDataset(series);
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = this.dataset.getSeries(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = dataset.getSeries(series);
compilation error,[CE] cannot find symbol series,   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer ixyd = dataset.getSeriesKey(series);
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.resetStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.expectStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.skipEndXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.incidentallyDefineXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.selectXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.incidentallySet(series, item);
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol limit,   ,if(includeInterval) { return null; } if(maximum > limit) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol maximal,   ,if(includeInterval) { return null; } if(includeInterval) { return new Range(minimum, maximal); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >=  maximum)  {    ,if(minimum >= maximum || maximum > range) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastChangeEvent(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastChangeGap(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getSecondYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastChild();
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol minimum, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { throw new IllegalArgumentException(""); }
compilation error,[CE] inconvertible types, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getSeriesCount(); }
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getDataset(dataset); }
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(); }
compilation error,[CE] cannot find symbol Range, double  minimum  =  Double.POSITIVE_INFINITY;  if(includeInterval)  {  double  maximum  =  Double.NEGATIVE_INFINITY;  }    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE; } if(dataset instanceof Range) { return Range; }
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY + Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series));
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY /(Double.isInfinite(series, item));
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double minimum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < cycleCount; series++) {
compilation error,[CE] cannot find symbol roundFloor, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < roundFloor; series++) {
compilation error,[CE] cannot find symbol rowCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < rowCount; series++) {
compilation error,[CE] cannot find symbol data, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < data.length; series++) {
compilation error,[CE] cannot find symbol numberCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < numberCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol startCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < startCount; series++) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2 + 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] cannot find symbol item, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-0, item);
patch is same with buggy,, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-0);
compilation error,[CE] cannot find symbol item, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series, item);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series+1);
compilation error,[CE] int cannot be dereferenced, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series).getItemCount();
increase failing tests, [FE] NullPointerException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-2);
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series, itemCount-1);
increase failing tests, [FE] IllegalArgumentException, int  itemCount  =  dataset.getItemCount(series-0);    ,int itemCount = dataset.getItemCount(series-3);
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY | Double.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NEGATIVE_INFINITY ET Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NegativeInfinition, double  maximum  =  Double.NEGATIVE_INFINITY  +  Integer.MAX_VALUE;    ,double maximum = Double.NegativeInfinition + Integer.MAX_VALUE;
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double minimum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol maximum, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximal = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] ')' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue) || Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof HorizonXYDataset) { dataset =(JavaXYDataset)dataset.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof Range) { dataset =(Range)dataset.getBaseValue(series, item); }
compilation error,[CE] '.class' expected,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getStartXValue(series,
compilation error,[CE] cannot find symbol series,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE; } if(dataset instanceof IntervalXYDataset) { dataset =(IntervalXYDataset)dataset.getBaseValue(series, item); }
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum!= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol min, if(minimum  ==  maximum)  {    ,if(maximum == min) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol pvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,pvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] cannot find symbol mvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,mvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol nvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,nvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,g2.setPaint(getItemPaint(series, item));
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] cannot find symbol pvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,pvalue = intervalXYData.getPosition(series, item);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] not a statement,   ,includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] not a statement,   ,(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] ';' expected,   ,boolean includeInterval = isInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum!= Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATING_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY), {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(series);
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, range); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { dataset.setSeriesKey(dataset.getSeriesKey(series)); if(!Double.isNaN(series)) { minimum = Math.min(minimum, number); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(series); if(!Double.isNaN(series)) { minimum = Math.min(minimum, seriesCount); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return null; }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException( " "); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(minimum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(minimum)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol count, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < count; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol columnCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < columnCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] incompatible types,   ,Double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MIN_VALUE + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MAX_VALUE + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol Min_VALUE,   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.Min_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | 1;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(maximum)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE + Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = getDataset(); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = new XYDataset(dataset.size());
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return super.iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset instanceof XYDataset) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); if(dataset!= null) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol periodXYData,   ,lvalue = periodXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getFirstXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol domainXYData,   ,lvalue = domainXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] cannot find symbol upper, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return new Range(minimum, upper, null); }
compilation error,[CE] incompatible types, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,return new NullPointerException("");
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(" "); }
compilation error,[CE] cannot find symbol max, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return new Range(minimum, max, null); }
compilation error,[CE] cannot find symbol MIN_VALUE, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return Range.MIN_VALUE; }
compilation error,[CE] cannot find symbol INCONCLUSIVE, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return Range.INCONCLUSIVE; }
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '|', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Integer.POSITIVE_INFINITY + Integer.MAX_VALUE * Double.POSITIVE_INFINITY;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; bodied else { throw new NullPointerException(" "); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; hopped else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; toured else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; meanwhile else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; delt else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; starred else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; figured else { throw new NullPointerException(" "); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; >> else { throw new NullPointerException(" "); }
compilation error,[CE] not a statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; bodied else { throw new NullPointerException( " "); }
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] cannot find symbol END_ARRAY, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < Series.END_ARRAY; item++) {
compilation error,[CE] cannot find symbol caseCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < caseCount; item++) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(3.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(10.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(4.0, 0.0);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 3;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | 1;
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol cycleCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < cycleCount; item++) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < SeriesCount; item++) {
compilation error,[CE] cannot find symbol periodCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < periodCount; item++) {
compilation error,[CE] cannot find symbol rowCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rowCount; item++) {
compilation error,[CE] cannot find symbol END_ARRAY, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < Series.END_ARRAY; item++) {
compilation error,[CE] cannot find symbol caseCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < caseCount; item++) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(lvalue > uvalue) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(lvalue > uvalue.length ||!Double.isNaN(lvalue)) {
compilation error,[CE] double cannot be dereferenced, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(lvalue > uvalue.length) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)* &&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.hasMeanValue(series, item); if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getEndXValue(series, item)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = intervalXYData.getItemCount(series);
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { if(getItemCount(series) > 1) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { XYDataset dataset = getDataset(series); if(dataset!= null) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() <= 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() <= 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(lvalue instanceof OHLCDataset &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Buffer, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Buffer.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)|| double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(getMinimumValue())) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(v0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(minum)) {
patch is same with buggy,, if(minimum  >=  maximum)  {    ,if(minimum >= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >=  maximum)  {    ,if(minimum >= maximum || maximum > range) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] class expected,   ,if(double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 3;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum!= Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || minimum!= Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY /(double)Double.NEGATIVE_INFINITY;
compilation error,[CE] method parseDouble in class Double cannot be applied to given types;, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY || Double.parseDouble(Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol doubleValue, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY || Double.doubleValue =(double)Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 || uvalue!= 1.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > max) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 ||!Util.isLiteralValue(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(uvalue > 0.0 || uvalue!=.maximum) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 || lvalue > 1.0) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0 ||!Util.isLiteralValue(series)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Uvalue.isNaN(uvalue)||!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol Uvalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Uvalue.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBoundsForXYDataset(dataset, false);
compilation error,[CE] cannot find symbol xYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.xYDataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtil.safeMultiply(this.dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toDomainBounds(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.lookupDomainBounds(dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.safeMultiply(this.getXYDataset()));
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum || minimum > maximum) {
patch is same with buggy,, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > maximum) {
compilation error,[CE] cannot find symbol range, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > range.length) {
compilation error,[CE] cannot find symbol limit, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > limit) {
compilation error,[CE] cannot find symbol upperBoundVal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > upperBoundVal) {
compilation error,[CE] cannot find symbol threshold, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > threshold) {
compilation error,[CE] cannot find symbol lowest, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > lowest) {
compilation error,[CE] double cannot be dereferenced, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum > minimum.length) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Buffer, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() <= 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] incompatible types,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { return new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement,   ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)/(Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)+(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY): Double.POSITIVE_INFINITY;
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)/(Double.NEGATIVE_INFINITY);
compilation error,[CE] : expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY): Double.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
compilation error,[CE] illegal start of expression, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < seriesCount; series+) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >= seriesCount; series++) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { if(dataset instanceof Range) { return(( Range)dataset).getRange(); }
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getRowCount() - 1;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { return(( IntervalXYDataset)dataset); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { return(Double)dataset; }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < null) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(upstream)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol duplicate, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(duplicate)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol k, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(k)) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.NEGATIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol optimum, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(optimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol major, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(major == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; for(int series = 0; series < dataset.getSeriesCount(); series++) { lvalue = dataset.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; for(int series = 0; series < dataset.getSeriesCount(); series++) { lvalue = dataset.getXValue(series, item); }
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { if(dataset instanceof Range) { return(( Range)dataset).getRange(); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; for(int series = 0; series < dataset.getSeriesCount(); series++) { lvalue = dataset.getStartXValue(series, item); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; if(lvalue > uvalue) { lvalue = dataset.getEndXValue(series, item); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY; if(lvalue > uvalue) { lvalue = dataset.getXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= 0.0) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= null) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= null &&!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() < 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum || minimum > maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum || minimum > maximum) {
compilation error,[CE] cannot find symbol upperBounds, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < upperBounds) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum <= maximum) {
compilation error,[CE] cannot find symbol upperBound, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximum || minimum < upperBound) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximal || minimum > maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum!= maximum || minimum > maximum) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(isGlobal()) { XYDataset dataset = getDataset(dataset); if(dataset!= null) { return new XYDataset(dataset, false); }
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] <identifier> expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { return Math.max
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(mini
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(max
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item - 1);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.ignoreXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.resetStartXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(duplicate)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ptr)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(k)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { range = intervalXYData.getRange(); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { setInterval(lvalue, intervalXYData.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { range = intervalXYData.getRange(); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, l
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item)); g2.setStroke(getItemStroke(series, item));
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol lvalue, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum =(double)Double.NEGATIVE_INFINITY + lvalue;
patch is same with buggy,, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getDecimalYValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getWeeksInYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getDouble(series, item);
compilation error,[CE] cannot find symbol lvalue, double  xyd  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item)- 1;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue) ||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getYValue(series, item);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getXValue(series, item);
compilation error,[CE] cannot find symbol item,   ,double xx = dataset.getXValue(series, item);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getItemX(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getSeriesCount();
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double ixyd = dataset.getSeriesCount();
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue))) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(Double.isNaN(lvalue)||(!Double.isNaN(uvalue))) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(lvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||(!Double.isNaN(uvalue)))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getDomainBounds();
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_Negative();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
compilation error,[CE] illegal start of expression, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < seriesCount; series+) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >= seriesCount; series++) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(( Range)dataset).getRange(); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { return(( IntervalXYDataset)dataset); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { return(Double)dataset; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { throw new IllegalArgumentException(""); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getDomainBounds();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum <= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Util.isMaximum(uvalue)||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount() - 1;
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(isGlobal()) { XYDataset dataset = getDataset(dataset); if(dataset!= null) { return new XYDataset(dataset, false); }
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum == minum) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum < minum) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= 0.0) { if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(lvalue)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null &&!Double.isNaN(lvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() / 2;
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double seriesCount = dataset.getRowCount();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount() * 2;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] unexpected type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue instanceof Math &&!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol minor, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(minor)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY / Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_FIELD_NAMES);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parse(dataset));
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseXYDataset(dataset));
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DateTimeZone.getDefault());
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseBounds(dataset));
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.isAssignableFrom(dataset));
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseBounds(dataset, true));
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = iterateRangeBounds();
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset, false));
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, true);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset));
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, true);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.createXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(dataset, false));
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected,   ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol y, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(y)) {
compilation error,[CE] cannot find symbol ptr, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol ivalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol xvalue, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(xvalue)) {
compilation error,[CE] cannot find symbol twins, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(twins)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue!= null) { if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,double uvalue = dataset.getXValue(series, item);
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,double uvalue = dataset.getUpperBound(true);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset, false));
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, true);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset));
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, true);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.createXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(dataset, false));
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(Util.isMaximum(getItemCount())) { if(uvalue > 0.0) {
compilation error,[CE] incompatible types, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) { return Math.max(uvalue, 0.0); }
compilation error,[CE] incompatible types, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) { return Math.max(uvalue, 0); }
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0 || uvalue < 0.0) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(this.includeInterval) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(isDomainBounds()) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(isExcludeInterval) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] , if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } while(System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(isEnabled(Feature.QUOTE_FIELD_NAMES)) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Double.POSITIVE_INFINITY); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, POSITIVE_INFINITY); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return Null; }
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new NullPointerException("Function values at endpoints do not have different signs."); }
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, Maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, Maximum); }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.min(minimum, Maximum); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval || dataset.getItemCount(series) < 0) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 2;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / 3;
compilation error,[CE] <identifier> expected,   ,double minimum = Double.POSITIVE_INFINITY, 0;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * 3;
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(i > 0) { i = ixyd.getEndYValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(i > 0) { return Math.min(i, 0); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(!Double.isNaN(i)) { i = ixyd.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(i > 0) { minimum = Math.min(minimum, i); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(!Double.isNaN(i)) { i = ixyd.getEndYValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(!Double.isNaN(i)) { minimum = Math.min(minimum, i); }
compilation error,[CE] 'else' without 'if',   ,if(i > 0) { double i = ixyd.getStartXValue(series, item); if(i > 0) { throw new NullPointerException(""); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol MIN_VALUE,   ,double minimum = Math.min(MIN_VALUE, Integer.MAX_VALUE);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; if(yesterday) { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; if(includeInterval) { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; if(throughput) { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; if(inerateRangeBounds) { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
increase failing tests, [FE] StackOverflowError, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; [Delete] else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] cannot find symbol includesInterval, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includesInterval); }
increase failing tests, [FE] StackOverflowError, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { return null; } else { return DatasetUtilities.iterateRangeBounds(dataset, includeInterval); }
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Integer.MAX_VALUE / Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE / Integer.MIN_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE / Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
compilation error,[CE] illegal start of expression, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < seriesCount; series+) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >= seriesCount; series++) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { double minimum = Double.POSITIVE_INFINITY; if(includeInterval) { double maximum = Double.NEGATIVE_INFINITY; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getstartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] ')' expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item;
compilation error,[CE] <identifier> expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item).
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol usvalue, if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(usvalue)) {
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRowKey(series, item);
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)) { return Math.min(lvalue, 0); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new NullPointerException(""); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] ';' expected,   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(); series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNa
compilation error,[CE] ';' expected,   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(); series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isN
compilation error,[CE] ';' expected,   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(); series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] ';' expected,   ,for(int series = 0; series < seriesCount; series++) { int seriesCount = dataset.getSeriesCount(); series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, range); if(!Double.isNa
compilation error,[CE] illegal start of expression,   ,for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(series)) { return 0; }
compilation error,[CE] illegal start of expression,   ,for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(series)) { return null; }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { return null; }
compilation error,[CE] illegal start of expression,   ,for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { return null; }
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { Integer ixyd = dataset.getSeries(series); if(ixyd!= null) { return XYDataset.getSeries(series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { Integer ixyd = dataset.getSeries(series); if(ixyd!= null) { return ixyd; }
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { ixyd.setSeriesKey(dataset.getSeriesKey(series)); }
compilation error,[CE] ')' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(ixyd.getEndYValue(series,
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series-1);
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series); if(itemCount > 1) { itemCount++; }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series-1); if(itemCount > 1) { itemCount++; }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series-1); if(itemCount > 1) { return Math.min(minimum, ivalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series); if(itemCount > 1) { return Math.min(minimum, ivalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series-1); if(itemCount > 1) { return Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series-1); if(itemCount > 0) { itemCount++; }
compilation error,[CE] cannot find symbol,   ,Int itemCount = dataset.getItemCount(series);
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { int itemCount = dataset.getItemCount(series); if(itemCount > 1) { return Math.min(minimum, lvalue); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { throw new NullPointerException("Function values at endpoints do not have different signs."); }
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(""); }
increase failing tests, [FE] NullPointerException, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { return null; } else { throw new NullPointerException(""); }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
compilation error,[CE] , if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; } else { throw new NullPointerException("")); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  throw  new  NullPointerException( " ");  }    ,if(!includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(" "); }
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount, item++) {
compilation error,[CE] cannot find symbol rangeCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] cannot find symbol listCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < listCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ohlc)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(expCase(uvalue))) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(range)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(ptr)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowKey(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { return Math.min(lvalue, 0); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new NullPointerException(""); }
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY / Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = ixyd.getItemCount(series);
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getItemCount(series)> 1) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(
compilation error,[CE] variable ixyd is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset ixyd = getDataset(series);
compilation error,[CE] variable itemCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int itemCount = ixyd.getItemCount(series);
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getItemCount(series)> 1) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getYValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(ixyd.getStartYValue(series, item)) { double lvalue = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) {
patch is same with buggy,, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.getEndYValue(series, item); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,double l = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol l, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { l = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.setEndYValue(series, item); }
compilation error,[CE] incompatible types, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { Double l = ixyd.getStartYValue(series, item); }
compilation error,[CE] cannot find symbol, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.setInterval(getStartYValue(series, item)); }
compilation error,[CE] cannot find symbol uvalue, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.getEndXValue(series, item); }
compilation error,[CE] ')' expected, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.putBounds(startYValue(series, item); }
compilation error,[CE] illegal start of expression, double  l  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); } else { ixyd.getEndYValue(series, item); >>
compilation error,[CE] cannot find symbol MAX_VALUE, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue > MAX_VALUE ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol MAXIMUM, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue > MAXIMUM ||!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +(includeInterval?  Double.POSITIVE_INFINITY  :  Double.POSITIVE_INFINITY);    ,double minimum = Double.POSITIVE_INFINITY || Double.MAX_VALUE;
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int itemCount = dataset.getItemCount(series);
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double itemCount = dataset.getItemCount(series);
compilation error,[CE] variable itemCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] cannot find symbol,   ,boolean itemCount = dataset.isItemCount(series);
compilation error,[CE] incompatible types,   ,double[] itemCount = dataset.getItemCount(series);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,boolean itemCount = dataset.getItemCount();
compilation error,[CE] incompatible types,   ,boolean itemCount = dataset.getSeriesCount();
compilation error,[CE] method getItemCount in interface XYDataset cannot be applied to given types;,   ,int itemCount = dataset.getItemCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '||',   ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY INFINITY / Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '|',   ,double minimum = Double.POSITIVE_INFINITY | Integer.MAX_VALUE;
compilation error,[CE] ';' expected,   ,double minimum = Double.POSITIVE_INFINITY AND Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE - 1;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol,   ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_INFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types,   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_INFINITY() * Double.NEGATIVE_INFINITY;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(maximum)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,double uvalue = dataset.getXValue(series, item);
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] illegal start of type, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,double uvalue = dataset.getUpperBound(true);
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol,   ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] incompatible types,   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol lvalue,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + lvalue;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] variable maximum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_FIELD_NAMES);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.WRITE_NULL_OBJECT);
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.WRITE_NULL_VALUE);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.UNKNOWN_EXPR_RESULT);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.AUTO_CLOSE);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.WRITE_NULL_POINT);
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { return new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] not a statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) { Throw new IllegalArgumentException("Null 'dataset' argument. "); }
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <=  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 2) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_FIELD_NAMES);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseDomainBounds(dataset));
compilation error,[CE] unreachable statement,   ,System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseDomainBounds(dataset, true));
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseDomainBounds(dataset), true);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseDomainBounds(dataset, this));
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.parseDomainBounds(dataset, false));
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
patch is same with buggy,, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] IllegalArgumentException, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] incompatible types, float  seriesCount  =  dataset.getSeriesCount();    ,boolean seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, float  seriesCount  =  dataset.getSeriesCount();    ,Int seriesCount = dataset.getSeriesCount();
increase failing tests, [FE] NullPointerException, float  seriesCount  =  dataset.getSeriesCount();    ,float seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol SeriesCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < SeriesCount; series++) {
compilation error,[CE] cannot find symbol periodCount, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < periodCount; series++) {
patch is same with buggy,, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series!= seriesCount; series++) {
increase failing tests, [FE] IllegalArgumentException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series <= seriesCount; series++) {
compilation error,[CE] incompatible types, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >> seriesCount; series++) {
compilation error,[CE] illegal start of expression, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series < seriesCount; series+) {
compilation error,[CE] ';' expected, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series { seriesCount; series++) {
increase failing tests, [FE] NullPointerException, for(int  series  =  0;  series!=  seriesCount;  series++)  {    ,for(int series = 0; series >= seriesCount; series++) {
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount() - 1;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] <identifier> expected, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY, 0;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol MAXIMUM, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(uvalue > MAXIMUM ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 2) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(10.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(2.0, Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(1.0, Double.POSITIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.001, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(3.0, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.05, Double.NEGATIVE_INFINITY);
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Math.max(0.0, Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5 * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol DOUBLE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Double.POSITIVE_INFINITY * Double.DOUBLE_INFINITY;
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0)) {
compilation error,[CE] cannot find symbol ohlc, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(expCase(uvalue))) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol range, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(range)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ptr)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol Locale, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum(Locale.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_NegativeInFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_NegativeInFINITY() / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_INFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_InFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getDomainBounds();
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double xyd = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol xyd, double  i  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(xyd)) { double xyd = ixyd.getStartXValue(series, item); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartYValue(series,  item);    ,if(includeInterval) { double xyd = ixyd.getStartXValue(series, item); if(!Double.isNaN(xyd)) { return Math.min(xyd, xyd); }
compilation error,[CE] cannot find symbol xyd, double  i  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(xyd)) { double xyd = ixyd.getStartXValue(series, item); } else { xyd = ixyd.getEndXValue(series, item); }
compilation error,[CE] ')' expected, double  i  =  ixyd.getStartYValue(series,  item);    ,if(!Double.isNaN(xyd)) { double xyd = ixyd.getStartXValue(series, item); if(!Double.isNaN(xyd)) { return Math.min(xyd, x
compilation error,[CE] cannot find symbol xyd, double  i  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double xyd = ixyd.getStartXValue(series, item); } else { xyd = ixyd.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,if(ixyd!= null) { double xyd = ixyd.getStartXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new NullPointerException("Function values at endpoints do not have different signs."); }
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator ,   ,if(uvalue!= null) { throw new NullPointerException(""); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Util.isMaximum(uvalue)||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset, false));
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, true);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset));
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, true);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.createXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(dataset, false));
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unclosed string literal,   ,if(!Double.isNaN(lvalue)&&!"Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartXValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(ixyd.getStartYValue(series, item) < 0) { return ixyd.getStartYValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(ixyd.getStartYValue(series, item) == 0) { return ixyd.getStartYValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartYValue(series, item); if(!Double.isNaN(lvalue)) { return Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(ixyd!= null) { double l = ixyd.getStartXValue(series, item); if(!Double.isNaN(lvalue)) { return Math.min(minimum, lvalue); }
compilation error,[CE] variable lvalue is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double lvalue = ixyd.getStartYValue(series, item);
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] incompatible types, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,return new NullPointerException("");
compilation error,[CE] missing return statement, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] cannot find symbol MIN_VALUE, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return Range.MIN_VALUE; }
compilation error,[CE] , if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,else if(includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] incompatible types, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return new NullPointerException(""); }
compilation error,[CE] cannot find symbol, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { throw new NullPointerException(""); } else { return nullPointerException(""); }
compilation error,[CE] non-static variable this cannot be referenced from a static context, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(this.includeInterval) { throw new NullPointerException(""); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol MAXIMUM, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue > MAXIMUM ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol y, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(y)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol xvalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(xvalue)) {
compilation error,[CE] cannot find symbol twins, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(twins)) {
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum =(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY -(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable minimum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_INFINITY);
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.getItemCount() > 0;
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item -= 0; item < itemCount; item++) {
increase failing tests, [FE]  Size, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_NegativeInfinite();
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] not a statement, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  ==  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] <identifier> expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.
compilation error,[CE] illegal start of expression,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { return Math.max
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(mini
compilation error,[CE] ')' expected,   ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(max
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol minuum, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minuum)) {
compilation error,[CE] cannot find symbol duplicate, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(duplicate)) {
increase failing tests, [FE] AssertionFailedError, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] cannot find symbol categoryCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < categoryCount; item++) {
patch is same with buggy,, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item!= itemCount; item++) {
compilation error,[CE] cannot find symbol itemsCount, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item -= 0; item < itemCount; item++) {
increase failing tests, [FE] ArrayIndexOutOfBoundsException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item <= itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 1; item < itemCount; item++) {
compilation error,[CE] incompatible types, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item >> itemCount; item++) {
increase failing tests, [FE] NullPointerException, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item == itemCount; item++) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue!= null) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum, lvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY|| maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum < Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum >= Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getDomainBounds();
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol,   ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue >= 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue < 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue <= 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue!= 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)/(uvalue > 0.0)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||(uvalue >= 0.0)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.Negative_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.NeGATIVE_INFINITY / Integer.MAX_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Double.MAX_VALUE;
increase failing tests, [FE] NullPointerException, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,uvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getEndXValue(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowKey(series, item);
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRowValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] cannot find symbol rvalue, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,rvalue = intervalXYData.getRangeXValue(series, item);
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { return Math.min(lvalue, 0); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new IllegalArgumentException(""); }
compilation error,[CE] 'else' without 'if', lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { if(!Double.isNaN(lvalue)) { throw new NullPointerException(""); }
patch is same with buggy,, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.setStartXValue(series, item);
compilation error,[CE] not a statement, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item)- 1;
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.insertXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.initStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item - 1);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.startXValue(series, item);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.ignoreXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);    ,intervalXYData.resetStartXValue(series, item);
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE / Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE * Integer.MIN_VALUE + Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] cannot find symbol POSITIVE_INFINITY, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Integer.POSITIVE_INFINITY * Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE * Integer.MIN_VALUE;
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setIntervalIndex(intervalXYData
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setInterval(intervalXYData, dataset, series, item); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,float seriesCount = dataset.getRowCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series,   ,float seriesIndex = dataset.getSeriesIndex(series);
compilation error,[CE] cannot find symbol,   ,float seriesIndex = dataset.getSeriesIndex();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,float seriesCount = dataset.getSeriesCount() + 1;
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.getSeriesCount() > 0;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_YValue(series, 0);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_YValue(series, item);
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > limit) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximal) {
compilation error,[CE] illegal start of expression,   ,if(minimum <= maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minimal) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol Util, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(Util.isMaximum(uvalue)||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] class expected, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)|| double.isInfinite(uvalue)) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(maximum > 0) {
increase failing tests, [FE]  double), if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, if(minimum  ==  maximum)  {    ,if(minimum > maximum) { throw new NullPointerException(""); }
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException(""); }
compilation error,[CE] constructor Range in class Range cannot be applied to given types;, if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum); }
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) { throw new IllegalArgumentException(""); }
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
compilation error,[CE] illegal start of expression, if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) {
compilation error,[CE] , if(minimum  ==  maximum)  {    ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException("")); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue!= 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue < 0.0) {
compilation error,[CE] cannot find symbol max, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > max) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] incompatible types,   ,return new NullPointerException(" ");
compilation error,[CE] non-static variable this cannot be referenced from a static context,   ,if(this.includeInterval) { throw new NullPointerException(""); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { throw new NullPointerException(""); } else { return new Range(minimum, maximum); }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { throw new NullPointerException("");
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(getDomainBounds() == 0) { return new NullPointerException(""); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(getDomainBounds() == 0) { throw new NullPointerException(""); }
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY / Integer.MIN_VALUE;
increase failing tests, [FE] AssertionFailedError, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY * Integer.MIN_VALUE;
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Integer.MIN_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MIN_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartXValue(series,  item);    ,double xx = ixyd.getXValue(series, item);
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(includeInterval) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { xx = ixyd.getXValue(series, item); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(includeInterval) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { minimum = Math.min(minimum, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(!Double.isNaN(xx)) { double xx = ixyd.getXValue(series, item); if(xx > 0) { return Math.min(xx, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(includeInterval) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { return Math.min(xx, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(includeInterval) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { return Math.min(maximum, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(!Double.isNaN(xx)) { double xx = ixyd.getXValue(series, item); if(xx > 0.0) { return Math.min(xx, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(!Double.isNaN(xx)) { double xx = ixyd.getXValue(series, item); if(xx > 0.0) { return Math.max(xx, 0.0); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(!Double.isNaN(xx)) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { return Math.min(xx, xx); }
compilation error,[CE] 'else' without 'if', double  i  =  ixyd.getStartXValue(series,  item);    ,if(!Double.isNaN(xx)) { double xx = ixyd.getXValue(series, item); if(!Double.isNaN(xx)) { return Math.min(maximum, xx); }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol MIN_VALUE,   ,double minimum = Math.min(MIN_VALUE, Integer.MAX_VALUE);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] incompatible types,   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol,   ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval) { (!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol limit, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol number, if(minimum  ==  Double.POSITIVE_INFINITY  ||  maximum  >  Double.POSITIVE_INFINITY)  {    ,if(number == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(itemCount)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(series)) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) {
compilation error,[CE] ,   ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException("")); }
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = dataset.getMaximum_NegativeInfinite();
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol ukvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol formatUtil, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(formatUtil.isNumeric(lvalue))) {
compilation error,[CE] cannot find symbol upstream, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(upstream)) {
compilation error,[CE] no suitable method found for isNaN(double,double), if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset, false));
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset), false);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(this.dataset, true);
compilation error,[CE] non-static variable this cannot be referenced from a static context, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(this.dataset));
compilation error,[CE] cannot find symbol XYDataset, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(XYDataset, true);
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.createXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.iterateXYDataset(dataset, false));
compilation error,[CE] cannot find symbol, return  iterateDomainBounds(dataset,  false);    ,return iterateDomainBounds(DatasetUtilities.toRawClass(dataset, false));
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] AssertionFailedError, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
compilation error,[CE] cannot find symbol item, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, item);
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).getItemCount();
increase failing tests, [FE] ArrayIndexOutOfBoundsException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] cannot find symbol column, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, column);
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if', if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue) ||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
patch is same with buggy,, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getStartXValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLastYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getEndXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLeftYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getDecimalYValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getWeeksInYValue(series, item);
compilation error,[CE] cannot find symbol lvalue, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getXValue(series, item);
compilation error,[CE] cannot find symbol, double  i  =  ixyd.getStartYValue(series,  item);    ,double i = ixyd.getLowerBound(series, item);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(double)Double.POSITIVE_INFINITY;
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] unclosed string literal, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!"Double.isInfinite(uvalue)) {
compilation error,[CE] class expected, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| double.isInfinite(uvalue)) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 2;
compilation error,[CE] ';' expected,   ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY - 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / 1;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY / 2;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_INFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_InFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Locale, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum(Locale.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_INFINITY() / Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_INFINITY() * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_InFINITY() / Double.POSITIVE_INFINITY;
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
compilation error,[CE] illegal start of expression,   ,if(maximum < minimum) {
compilation error,[CE] illegal start of expression,   ,if(maximum == minimal) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum) {
compilation error,[CE] illegal start of expression,   ,if(minimum == maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > minum) {
compilation error,[CE] illegal start of expression,   ,if(maximum < minum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(maximum > minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol limit, if(minimum  >=  maximum)  {    ,if(maximum > limit) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >=  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum > minimal) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / 2.0;
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / 2.0;
compilation error,[CE] inconvertible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum =(Double)Double.POSITIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NeGATIVE_INFINITY / 2.0;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.Negative_INFINITY / 2.0;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NaN / 2.0;
patch is same with buggy,, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series);
compilation error,[CE] cannot find symbol item, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, item);
compilation error,[CE] non-static variable this cannot be referenced from a static context, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = this.dataset.getItemCount(series);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)- 1;
increase failing tests, [FE] IllegalArgumentException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series + 1);
increase failing tests, [FE] NullPointerException, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series)+ 1;
compilation error,[CE] int cannot be dereferenced, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series).getItemCount();
compilation error,[CE] cannot find symbol column, float  itemCount  =  dataset.getItemCount(series);    ,float itemCount = dataset.getItemCount(series, column);
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY - 1;
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval) { (!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) {
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] 'else' without 'if', for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(minimum,
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.max
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math
compilation error,[CE] ';' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { return Math.max
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(mini
compilation error,[CE] ')' expected, for(int  item  =  0;  item!=  itemCount;  item++)  {    ,for(int item = 0; item < itemCount; item++) { if(intervalXYData.getStartXValue(series, item)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(uvalue)) { minimum = Math.min(max
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(intervalXYDataset)) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!IncludeInterval && dataset instanceof IntervalXYDataset && dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval && dataset instanceof IntervalXYDataset) {
compilation error,[CE] no suitable method found for isNaN(boolean),   ,if(!Double.isNaN(includeInterval)) { return dataset; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval || dataset instanceof IntervalXYDataset) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(dataset)) {
compilation error,[CE] illegal start of expression,   ,if(!Double.isNaN(includeInterval)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] bad operand types for binary operator '!=', if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(uvalue!= null) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue) ||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(itemCount)) {
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY *(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY /(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)+(includeInterval? Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY): Double.POSITIVE_INFINITY;
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)/(Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);
compilation error,[CE] : expected,   ,double minimum = Double.POSITIVE_INFINITY +(includeInterval? Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY)*(Double.POSITIVE_INFINITY : Double.POSITIVE_INFINITY);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(); if(series < 0) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)DatasetUtilities.getDataset(series);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset = DatasetUtilities.getDataset(dataset);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(); if(series >= 0) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,Range dataset =(Range)DatasetUtilities.getIntervalXYDataset(dataset);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(); if(series < 0) { return ixyd; }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isInfinite(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] unclosed string literal,   ,if(!Double.isNaN(lvalue)&&!"Double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getDomainBounds();
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_Negative();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = dataset.getMaximum_NegativeInFINITY();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY / Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY * Integer.MAX_VALUE;
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] variable minimum is already defined in method iterateRangeBounds(XYDataset,boolean),   ,double minimum = Double.POSITIVE_INFINITY - Integer.MAX_VALUE;
compilation error,[CE] cannot find symbol MIN_VALUE,   ,double minimum = Math.min(MIN_VALUE, Integer.MAX_VALUE);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRangeBounds(); }
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_INFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getMaximum_INFINITY() * Double.NEGATIVE_INFINITY;
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol limit, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] ')' expected,   ,lvalue = intervalXYData.getStartXValue(series, item;
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || isInfinite(uvalue)) {
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Math.max(minimum, maximum));
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.ERROR);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.max(minimum, Math.min(minimum, maximum));
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, range);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Integer.MAX_VALUE);
compilation error,[CE] ')' expected, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.max(minimum, Math.min(minimum, maximum);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Maximum.MISMATCH);
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, Math.max(minimum, maximal));
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);    ,minimum = Math.min(minimum, 0);
compilation error,[CE] ')' expected,   ,if(includeInterval) { intervalXYData.getStartXValue(series, item); } else { setInterval(intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,intervalXYData.setStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,l value = intervalXYData.getStartXValue(series, item);
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { intervalXYData.getStartXValue(series, item); } else { setInterval(intervalXYData.getEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { intervalXYData.getStartXValue(series, item); } else { addInterval(intervalXYData.getEndXValue(series, item); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > minimum) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(minimum)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(ukvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(upstream)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < seriesCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < categoryCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < itemsCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item!= itemCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item <= itemCount; item++) {
compilation error,[CE] ';' expected,   ,for(int item = 0; item < itemCount, item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < rangeCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 0; item < listCount; item++) {
compilation error,[CE] 'else' without 'if',   ,for(int item = 1; item < itemCount; item++) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum == minum) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(maximum > minimum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  ==  maximum)  {    ,if(maximum == minimal) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  maximum)  {    ,if(minimum < maximum) {
patch is same with buggy,, if(minimum  ==  maximum)  {    ,if(minimum == maximum) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol minum, if(minimum  ==  maximum)  {    ,if(maximum < minum) {
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(isGlobal()) { XYDataset dataset = getDataset(dataset); if(dataset!= null) { return new XYDataset(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, false); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,if(dataset!= null) { XYDataset dataset = new XYDataset(dataset.size()); iterateDomainBounds(dataset, false); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(dataset); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { return iterateDomainBounds(dataset, true); }
compilation error,[CE] variable dataset is already defined in method iterateDomainBounds(XYDataset),   ,XYDataset dataset = getDataset(); iterateDomainBounds(dataset, false);
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDatasets()) { if(dataset.size() > 0) { iterateDomainBounds(dataset, true); }
compilation error,[CE] illegal start of expression,   ,if(isGlobal()) { XYDataset dataset = getDataset(dataset); if(dataset!= null) { return new XYDataset(dataset, false); }
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '/', if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)/!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) || Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol usvalue, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(usvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&& Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0.0)) {
compilation error,[CE] no suitable method found for isInfinite(double,int), if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue, 0)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] bad operand types for binary operator '&&', if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)&& Math.max(uvalue, 0)) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > minimum) {
increase failing tests, [FE] NullPointerException, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum < maximum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol limit, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > limit) {
compilation error,[CE] cannot find symbol maximal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum > maximal) {
increase failing tests, [FE]  double), if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(minimum <= maximum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >  maximum  ||  minimum  >  maximum)  {    ,if(maximum > minimal) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol MAX_VALUE, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > MAX_VALUE ||!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
compilation error,[CE] cannot find symbol MAXIMUM, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(uvalue > MAXIMUM ||!Double.isNaN(uvalue)||!Double.isNaN(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isNaN(lvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximumNumber();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getDomainBounds();
compilation error,[CE] incompatible types,   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_Negative();
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,double maximum = dataset.getMaximum_NegativeInFINITY();
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0.0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue < 0) { if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0.0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(lvalue!= 0) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_FIELD_NAMES);
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException(""); }
compilation error,[CE] for-each loops are not supported in -source 1.4,   ,for(XYDataset dataset : getDataset()) { if(includeInterval) { return null; }
compilation error,[CE] 'else' without 'if',   ,while(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.WRITE_NULL_OBJECT);
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; } else { throw new NullPointerException(""); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue!= 0.0) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(uvalue <= 0.0) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(Util.isMaximum(getItemCount())) { if(uvalue > 0.0) {
compilation error,[CE] incompatible types, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) { return Math.max(uvalue, 0.0); }
compilation error,[CE] incompatible types, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0) { return Math.max(uvalue, 0); }
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!includeInterval) { if(uvalue > 0.0 || uvalue < 0.0) {
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol NeGATIVE_INFINITY,   ,double maximum = Double.NeGATIVE_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY * Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol lvalue,   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + lvalue;
compilation error,[CE] cannot find symbol Negative_INFINITY,   ,double maximum = Double.Negative_INFINITY / Double.POSITIVE_INFINITY;
compilation error,[CE] variable maximum is already defined in method iterateDomainBounds(XYDataset,boolean),   ,double maximum = Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue!= null) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||(uvalue!= null &&!Double.isNaN(uvalue))) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_FIELD_NAMES)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||(includeInterval &&!Double.isNaN(uvalue))) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||(!Double.isNaN(uvalue))) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&& isEnabled(Feature.QUOTE_INFINITY)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { Integer ixyd = dataset.getSeries(series); if(ixyd!= null) { return XYDataset.getSeries(series); }
compilation error,[CE] 'else' without 'if',   ,for(int series = 0; series < seriesCount; series++) { Integer ixyd = dataset.getSeries(series); if(ixyd!= null) { return ixyd; }
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { ixyd.setSeriesKey(dataset.getSeriesKey(series)); }
compilation error,[CE] ')' expected,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(!Double.isNaN(
compilation error,[CE] illegal start of expression,   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); if(ixyd.getEndYValue(series,
compilation error,[CE] cannot find symbol,   ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { return Math.min(series, 0); }
compilation error,[CE] 'else' without 'if',   ,int seriesCount = dataset.getSeriesCount(); for(int series = 0; series < seriesCount; series++) { if(!Double.isNaN(series)) { minimum = Math.min(minimum, lvalue); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(seriesCount)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(series)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(?Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression,   ,if(?Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5 * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol GLOBAL_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  -  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.GLOBAL_INFINITY;
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY);
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, Maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, Maximum); }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.max(minimum, Maximum.POSITIVE_INFINITY); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] cannot find symbol Maximum,   ,minimum = Math.min(minimum, Maximum); if(minimum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
increase failing tests, [FE] NullPointerException, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] 'else' without 'if', if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(includeInterval) { if(!Double.isNaN(uvalue)&&!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue) ||!Double.isNaN(itemCount)) {
increase failing tests, [FE] AssertionFailedError, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)&&!Double.isNaN(itemCount)) {
compilation error,[CE] cannot find symbol, if(includeInterval  &&!Double.isNaN(uvalue))  {    ,if(isNaN(uvalue)||!Double.isNaN(itemCount)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset.getRange(); }
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,if(includeInterval) { if(dataset instanceof Range) { return(Range)dataset; }
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,Int seriesCount = dataset.getSeriesCount();
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,boolean includeInterval = dataset.isIncludeInterval();
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,if(includeInterval) { if(dataset instanceof Range) { return(RelativeAccuracy * Math.max(0.0, 0.0)); }
compilation error,[CE] cannot find symbol series, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = dataset.getXValue(series, 0);
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,if(includeInterval) { if(dataset instanceof Range) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,if(includeInterval) { if(dataset instanceof Range) { return(range)dataset.getRange(); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)/!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Buffer.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.NEGATIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(maximum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(limit == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
compilation error,[CE] class expected,   ,if(minimum == Double.POSITIVE_INFINITY || maximum == double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
compilation error,[CE] illegal start of expression,   ,if(minimum == Integer.MIN_VALUE || maximum == Integer.MAX_VALUE) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval || dataset.getItemCount(series) < 0) {
patch is same with buggy,, if(uvalue  >  0.0)  {    ,if(uvalue > 0.0) {
compilation error,[CE] cannot find symbol max, if(uvalue  >  0.0)  {    ,if(uvalue > max) {
increase failing tests, [FE]  double), if(uvalue  >  0.0)  {    ,if(uvalue < 0.0) {
increase failing tests, [FE] NullPointerException, if(uvalue  >  0.0)  {    ,if(uvalue!= 0.0) {
increase failing tests, [FE]  double), if(uvalue  >  0.0)  {    ,if(uvalue <= 0.0) {
compilation error,[CE] cannot find symbol maximal, if(uvalue  >  0.0)  {    ,if(uvalue > maximal) {
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 1) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() <= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount()!= 2) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() > 0) {
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,[Delete]
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(this.includeInterval) { if(includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
increase failing tests, [FE] NullPointerException, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(!includeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(isEnabled(Feature.QUOTE_FIELD_NAMES)) { if(includeInterval) { return null; }
patch is same with buggy,, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } else { System.err.println("Unable to parse: " + dataset); return new Range(minimum, maximum); }
compilation error,[CE] cannot find symbol IncludeInterval, if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(IncludeInterval) { return null; } else { System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] , if(includeInterval)  {  return  null;  }  else  {  System.err.println( "Unable  to  parse: "  +  dataset);  return  new  Range(minimum,  maximum);  }    ,if(includeInterval) { return null; } while(System.err.println("Unable to parse:" + dataset); return new Range(minimum, maximum); }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable:" + dataset.getClass().getName()); }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval();
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined variable: " + dataset.getClass().getName()); }
compilation error,[CE] variable includeInterval is already defined in method iterateDomainBounds(XYDataset,boolean),   ,boolean includeInterval = isInterval(); if(includeInterval) { return this; }
compilation error,[CE] unreachable statement,   ,if(includeInterval) { return null; } else { throw new NullPointerException("Undefined dataset:" + dataset.getClass().getName()); }
increase failing tests, [FE] NullPointerException, if(minimum  >=  maximum)  {    ,if(maximum > minimum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(maximum >= minimum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum > minum) {
compilation error,[CE] cannot find symbol minum, if(minimum  >=  maximum)  {    ,if(maximum >= minum) {
compilation error,[CE] cannot find symbol minimal, if(minimum  >=  maximum)  {    ,if(maximum >= minimal) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum <= maximum) {
increase failing tests, [FE]  double), if(minimum  >=  maximum)  {    ,if(minimum < maximum) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
patch is same with buggy,, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(ptr)) {
compilation error,[CE] cannot find symbol minuum, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minuum, uvalue)) {
compilation error,[CE] cannot find symbol tv, if(!Double.isNaN(uvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(tv)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(?Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol usvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(usvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol uge, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uge)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol upstream, if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(upstream)) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount()!= 2) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 0.5 * Double.NEGATIVE_INFINITY;
compilation error,[CE] no suitable method found for max(double), double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Math.max(Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY + 1;
compilation error,[CE] cannot find symbol DOUBLE_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  +  1;    ,double maximum = Double.POSITIVE_INFINITY * Double.DOUBLE_INFINITY;
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] cannot find symbol minuum, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minuum)) {
compilation error,[CE] cannot find symbol minor, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minor)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(lvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol max, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || max == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol maximal, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximal == Double.POSITIVE_INFINITY) {
increase failing tests, [FE]  double), if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(maximum == Double.POSITIVE_INFINITY || maximum == Double.POSITIVE_INFINITY) {
increase failing tests, [FE] NullPointerException, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(minimum == Double.POSITIVE_INFINITY || maximum!= Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol optimum, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(optimum == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
compilation error,[CE] cannot find symbol major, if(minimum  ==  Double.POSITIVE_INFINITY  ||  minimum  ==  Double.POSITIVE_INFINITY)  {    ,if(major == Double.POSITIVE_INFINITY || minimum == Double.POSITIVE_INFINITY) {
patch is same with buggy,, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY * 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY + 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol Negative_INFINITY, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = Double.Negative_INFINITY / Double.NEGATIVE_INFINITY + 1;
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() < 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRangeCount();
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMeanValue(series, 0);
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, 0);
compilation error,[CE] cannot find symbol,   ,int rangeCount = dataset.getRangeCount();
compilation error,[CE] incompatible types,   ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol,   ,Integer seriesCount = dataset.getRangeCount();
compilation error,[CE] cannot find symbol,   ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol series,   ,double maximum = dataset.getMaximumYValue(series, item);
compilation error,[CE] variable seriesCount is already defined in method iterateRangeBounds(XYDataset,boolean),   ,int seriesCount = dataset.getSeriesCount() - 1;
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < upperBounds) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < upper) {
compilation error,[CE] illegal start of expression,   ,if(minimum < maximum || minimum > range) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < range) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < lower) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < size) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < values.length) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < absolute) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < threshold) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum || minimum < height) {
patch is same with buggy,, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setIntervalIndex(intervalXYData
compilation error,[CE] cannot find symbol, lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setInterval(intervalXYData, dataset, series, item); }
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] cannot find symbol minum, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(uvalue)||!Double.isNaN(minum)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(uvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol IncludeInterval, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!IncludeInterval &&!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(!Double.isNaN(lvalue)|| Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol Lvalue, if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue))  {    ,if(Lvalue.isMinimum(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { range = intervalXYData.getRange(); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { setInterval(lvalue, intervalXYData.getEndXValue(series, item); }
compilation error,[CE] cannot find symbol,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] ')' expected,   ,if(includeInterval) { lvalue = intervalXYData.getStartXValue(series, item); } else { range = intervalXYData.getRange(); if(!Double.isNaN(lvalue)) { minimum = Math.min(minimum, l
compilation error,[CE] cannot find symbol,   ,g2.setPaint(getItemPaint(series, item)); g2.setStroke(getItemStroke(series, item));
compilation error,[CE] cannot find symbol rvalue,   ,rvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 2) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() > 0) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() < 2) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(isNaN(uvalue)||!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)||!Double.isNaN(uvalue)) {
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(10.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(3.0, 0.0);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(5.0, 0.0);
increase failing tests, [FE] NullPointerException, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(30.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(4.0, 0.0);
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  /  2;    ,double maximum = Math.max(8.0, 0.0);
patch is same with buggy,, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY + Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Integer.MAX_VALUE;
compilation error,[CE] ';' expected, double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY, Integer.MAX_VALUE;
compilation error,[CE] bad operand types for binary operator '||', double  minimum  =  Double.POSITIVE_INFINITY  +  Integer.MAX_VALUE;    ,double minimum = Double.POSITIVE_INFINITY || Double.MAX_VALUE;
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > maximum) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval &&!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(maximum)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)|| Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)||!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(uvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(uvalue > 0.0) {
compilation error,[CE] illegal start of expression,   ,if(minimum > maximum) {
compilation error,[CE] illegal start of expression,   ,if(maximum > 0) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException(""); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { return new Range(minimum); }
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) { throw new IllegalArgumentException(""); }
compilation error,[CE] illegal start of expression,   ,if(maximum > minimum) {
compilation error,[CE] illegal start of expression,   ,if(!includeInterval) { if(minimum > maximum) {
compilation error,[CE] ,   ,if(!includeInterval) { if(minimum > maximum) { throw new NullPointerException("")); }
increase failing tests, [FE] AssertionFailedError,   ,lvalue = intervalXYData.getStartXValue(series, item)- 1;
increase failing tests, [FE]  Size,   ,lvalue = intervalXYData.getStartXValue(series, item + 1);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getstartXValue(series, item);
increase failing tests, [FE] NullPointerException,   ,lvalue = intervalXYData.getStartXValue(series, item)+ 1;
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartingXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getBeginXValue(series, item);
compilation error,[CE] cannot find symbol,   ,lvalue = intervalXYData.getStartxValue(series, item);
compilation error,[CE] ')' expected,   ,lvalue = intervalXYData.getStartXValue(series, item;
compilation error,[CE] double cannot be dereferenced,   ,lvalue = intervalXYData.getStartXValue(series, item).
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(minimum)) {
compilation error,[CE] 'else' without 'if',   ,if(!IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(IncludeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isNaN(maximum, lvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isNaN(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_INFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_InFINITY() * Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol Locale, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum(Locale.NEGATIVE_INFINITY);
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_INFINITY();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_INFINITY() / Double.POSITIVE_INFINITY;
compilation error,[CE] incompatible types, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,Integer seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_INFINITY() * Double.NEGATIVE_INFINITY;
compilation error,[CE] cannot find symbol, double  maximum  =  Double.NEGATIVE_INFINITY  /  2.0;    ,double maximum = dataset.getMaximum_InFINITY() / Double.POSITIVE_INFINITY;
compilation error,[CE] cannot find symbol ohlc, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ohlc)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(uvalue)&&!Double.isNaN(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(expCase(uvalue))) {
compilation error,[CE] cannot find symbol ivalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ivalue)) {
compilation error,[CE] cannot find symbol ukvalue, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ukvalue)) {
compilation error,[CE] cannot find symbol range, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(range)) {
compilation error,[CE] cannot find symbol ptr, if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(uvalue)&&!Double.isNaN(ptr)) {
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY;
compilation error,[CE] ';' expected, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY - 1;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.POSITIVE_INFINITY / 2;
increase failing tests, [FE] AssertionFailedError, double  maximum  =  Double.NEGATIVE_INFINITY  *  2;    ,double maximum = Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY;
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
patch is same with buggy,, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) {
increase failing tests, [FE] IllegalArgumentException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] unreachable statement, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
increase failing tests, [FE] NullPointerException, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 2) {
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() == 0) { return new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of type, if(dataset  ==  null  ||  dataset.getSeriesCount()  <  0)  {    ,if(dataset == null || dataset.getSeriesCount() < 0) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)&&!Double.isInfinite(lvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isInfinite(lvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(Double.isInfinite(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] cannot find symbol, if(!Double.isNaN(lvalue)||  Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&& isInfinite(lvalue)) {
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,lvalue = intervalXYData.getStartXValue(series, item);
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.getEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setEndXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] variable uvalue might not have been initialized, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(!includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); }
compilation error,[CE] ')' expected, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(intervalXYData!= null) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setIntervalIndex(intervalXYData
compilation error,[CE] cannot find symbol, intervalXYData.getStartXValue(series,  item);  lvalue  =  intervalXYData.getStartXValue(series,  item);    ,if(includeInterval) { intervalXYData.getStartXValue(series, item); lvalue = intervalXYData.getStartXValue(series, item); } else { intervalXYData.setInterval(intervalXYData, dataset, series, item); }
patch is same with buggy,, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(includeInterval ||!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of expression, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(?Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue))  {    ,if(Double.isNaN(lvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(Feature.QUOTE_FIELD_NAMES);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(DatasetUtilities.getDefaultInterval());
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(this.dataset!= null) { return new Range(minimum, maximum); }
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset();
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(includeInterval) { return null; }
compilation error,[CE] illegal start of expression,   ,if(includeInterval) { if(this.dataset!= null) { return this; }
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(JsonScope.DANGLE_FONT);
compilation error,[CE] variable dataset is already defined in method iterateRangeBounds(XYDataset,boolean),   ,XYDataset dataset = getDataset(includeInterval);
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(JXPathIntrospector.getBeanInfo(this));
compilation error,[CE] variable includeInterval is already defined in method iterateRangeBounds(XYDataset,boolean),   ,boolean includeInterval = isEnabled(JsonScope.UNKNOWN);
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() < 0) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 1) {
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 0) { throw new IllegalArgumentException("Null 'dataset' argument. ");
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() == 2) {
increase failing tests, [FE] IllegalArgumentException,   ,if(dataset == null || dataset.getSeriesCount() == 1) { throw new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] incompatible types,   ,if(dataset == null || dataset.getSeriesCount() == 0) { return new IllegalArgumentException("Null 'dataset' argument. "); }
compilation error,[CE] illegal start of expression,   ,if(dataset == null || dataset.getSeriesCount() <= 0) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval ||!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(includeInterval) { if(!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] not a statement,   ,if(includeInterval) { (!Double.isNaN(lvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(Double.isNaN(lvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if',   ,if(!Double.isNaN(lvalue) ||!Double.isInfinite(uvalue)) {
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Maximum); if(maximum == Double.POSITIVE_INFINITY) { return null; }
patch is same with buggy,, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Maximum); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(minimum == Double.POSITIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, Double.POSITIVE_INFINITY); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, POSITIVE_INFINITY); if(maximum == Double.NEGATIVE_INFINITY) { return null; }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.NEGATIVE_INFINITY) { return new Range(minimum, maximum); }
compilation error,[CE] illegal start of type, minimum  =  Math.min(minimum,  maximum);  if(maximum  ==  Double.NEGATIVE_INFINITY)  {  return  null;  }    ,minimum = Math.min(minimum, maximum); if(maximum == Double.POSITIVE_INFINITY) { return Null; }
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue instanceof Double) { if(!Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
increase failing tests, [FE] AssertionFailedError, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(Double.isNaN(uvalue)|| Double.isInfinite(uvalue)) {
increase failing tests, [FE] NullPointerException, if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(Double.isNaN(uvalue)&&!Double.isInfinite(uvalue)) {
compilation error,[CE] 'else' without 'if', if(!Double.isNaN(uvalue)&&!Double.isNaN(maximum))  {    ,if(uvalue!= null) { if(!Double.isNaN(uvalue)||!Double.isInfinite(uvalue)) {
compilation error,[CE] variable seriesCount is already defined in method iterateDomainBounds(XYDataset,boolean), double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,int seriesCount = dataset.getSeriesCount();
compilation error,[CE] cannot find symbol, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,int seriesCount = dataset.getRowCount();
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { if(dataset instanceof Range) { return(( Range)dataset).getRange(); }
compilation error,[CE] illegal start of expression, double  minimum  =  Double.POSITIVE_INFINITY  -  1;    ,if(includeInterval) { if(dataset instanceof IntervalXYDataset) { return(( IntervalXYDataset)dataset); }
