bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  mant  =  field.getItemCount()  -  1;  [CE]  illegal  start  of  type  [FE]        AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getItemCount()  -  1;  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getItemCount()  -  1;	      int    mant    =    field.getItemCount();    	non-compiled	[CE]  illegal  start  of  type	7	None	replace
2	[BUG]  [BUGGY]  int  mant  =  field.getItemCount(rh);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getItemCount(rh);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getItemCount(rh);	      int    mant    =    field.getItemCount(x);    	non-compiled	[CE]  illegal  start  of  type	8	None	replace
3	[BUG]  [BUGGY]  int  mant  =  Math.min(mant.length,  RADIX);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  Math.min(mant.length,  RADIX);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  Math.min(mant.length,  RADIX);	      int    mant    =    Math.min(mant.length,    rh);    	non-compiled	[CE]  illegal  start  of  type	11	None	replace
4	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.FLAG_INVALID,  x);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.FLAG_INVALID,  x);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.FLAG_INVALID,  x);	      int    mant    =    field.getField(DfpField.FLAG_INVALID);    	non-compiled	[CE]  illegal  start  of  type	5	None	replace
5	[BUG]  [BUGGY]  int  mant  =  Math.min(mant.length,  x  +  1,  result.nans);  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  Math.min(mant.length,  x  +  1,  result.nans);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  Math.min(mant.length,  x  +  1,  result.nans);	      int    mant    =    Math.min(mant.length,    x    +    1);    	non-compiled	[CE]  illegal  start  of  type	12	None	replace
6	[BUG]  [BUGGY]  int  mant[]  =  field.getField(DfpField.FLAG_INVALID);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant[]  =  field.getField(DfpField.FLAG_INVALID);  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant[]  =  field.getField(DfpField.FLAG_INVALID);	      	non-compiled	[CE]  illegal  start  of  type	3	None	replace
7	[BUG]  [BUGGY]  int  mant[]  =  field.getField(DfpField.FIELD_INVALID,  x);  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant[]  =  field.getField(DfpField.FIELD_INVALID,  x);  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant[]  =  field.getField(DfpField.FIELD_INVALID,  x);	      	non-compiled	[CE]  illegal  start  of  type	3	None	replace
8	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  RADIX);  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  RADIX);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_EXP,  RADIX);	      int    mant    =    field.getField(DfpField.MAX_EXP,    x);    	non-compiled	[CE]  illegal  start  of  type	6	None	replace
9	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  rh);  [CE]  illegal  start  of  type  [FE]              AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  rh);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_EXP,  rh);	      int    mant    =    field.getField(DfpField.MAX_EXP,    x);    	non-compiled	[CE]  illegal  start  of  type	6	None	replace
10	[BUG]  [BUGGY]  Integer  mant  =  result.nans  -  1;  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  Integer  mant  =  result.nans  -  1;  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	Integer  mant  =  result.nans  -  1;	      Integer    mant    =    result.nans;    	non-compiled	[CE]  illegal  start  of  type	9	None	replace
11	[BUG]  [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  for(int  i  =  1;  i  <  mant.length;  i++)  {  [CE]  illegal  start  of  expression  [FE]    AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  for(int  i  =  1;  i  <  mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	for(int    i    =    1;    i    <    mant.length;    i++)    {    for(int  i  =  1;  i  <  mant.length;  i++)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
12	[BUG]  [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  For(int  i  =  1;  i  <  mant.length;  i++)  {  [CE]  '.class'  expected  [FE]      AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  For(int  i  =  1;  i  <  mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	for(int    i    =    1;    i    <    mant.length;    i++)    {    For(int  i  =  1;  i  <  mant.length;  i++)  {	  	non-compiled	[CE]  '.class'  expected	1	None	add
13	[BUG]  [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  int  i  =  1;  i  <  mant.length;  i++)  {  [CE]  >  expected  [FE]        AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  int  i  =  1;  i  <  mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	for(int    i    =    1;    i    <    mant.length;    i++)    {    int  i  =  1;  i  <  mant.length;  i++)  {	  	non-compiled	[CE]  >  expected	1	None	add
14	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MIN_EXP);  [CE]  illegal  start  of  type  [FE]        AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MIN_EXP);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MIN_EXP);	      int    mant    =    field.getField(DfpField.MAX_EXP);    	non-compiled	[CE]  illegal  start  of  type	4	None	replace
15	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_QUOTE);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_QUOTE);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_QUOTE);	      int    mant    =    field.getField(DfpField.MAX_EXP);    	non-compiled	[CE]  illegal  start  of  type	4	None	replace
16	[BUG]  [BUGGY]  [FE]  AssertionError  [FE]    AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  result.mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	add	for(int  i  =  1;  i  <  result.mant.length;  i++)  {	  for(int    i    =    1;    i    <    mant.length;    i++)    {    	compilable	  [FE]  AssertionError  	2	1	replace
17	[BUG]  [BUGGY]  for(int  i  =  1;  i  <  result.mant.length;  i++)  {  [FE]  AssertionError  [FE]    AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  result.mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	for(int  i  =  1;  i  <  result.mant.length;  i++)  {	  for(int    i    =    1;    i    <    mant.length;    i++)    {    	compilable	  [FE]  AssertionError  	2	1	replace
18	[BUG]  [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  final  int  i  =  1;  i  <  mant.length;  i++)  {  [CE]  >  expected  [FE]    AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  for(int  i  =  1;  i  <  mant.length;  i++)  {  final  int  i  =  1;  i  <  mant.length;  i++)  {  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	for(int    i    =    1;    i    <    mant.length;    i++)    {    final  int  i  =  1;  i  <  mant.length;  i++)  {	  	non-compiled	[CE]  >  expected	1	None	add
19	[BUG]  [BUGGY]  int  rh  =  Math.min(mant.length,  result.nans);  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  rh  =  Math.min(mant.length,  result.nans);  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  rh  =  Math.min(mant.length,  result.nans);	      	non-compiled	[CE]  illegal  start  of  type	3	None	replace
20	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MIN_EXP,  x);  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MIN_EXP,  x);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MIN_EXP,  x);	      int    mant    =    field.getField(DfpField.MAX_EXP,    x);    	non-compiled	[CE]  illegal  start  of  type	6	None	replace
21	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  MIN_EXP);  [CE]  illegal  start  of  type  [FE]        AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  MIN_EXP);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_EXP,  MIN_EXP);	      int    mant    =    field.getField(DfpField.MAX_EXP);    	non-compiled	[CE]  illegal  start  of  type	4	None	replace
22	[BUG]  [BUGGY]  int  r  =  mant[i]  *  RADIX;  [CE]  illegal  start  of  type  [FE]          AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  r  =  mant[i]  *  RADIX;  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  r  =  mant[i]  *  RADIX;	      	non-compiled	[CE]  illegal  start  of  type	3	None	replace
23	[BUG]  [BUGGY]  Integer  r  =  result.mant[i]  *  RADIX;  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  Integer  r  =  result.mant[i]  *  RADIX;  [BUGGY]    final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	Integer  r  =  result.mant[i]  *  RADIX;	      	non-compiled	[CE]  illegal  start  of  type	3	None	replace
24	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  adiff);  [CE]  illegal  start  of  type  [FE]            AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_EXP,  adiff);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_EXP,  adiff);	      int    mant    =    field.getField(DfpField.MAX_EXP,    x);    	non-compiled	[CE]  illegal  start  of  type	6	None	replace
25	[BUG]  [BUGGY]  int  mant  =  field.getField(DfpField.MAX_SCALE);  [CE]  illegal  start  of  type  [FE]        AssertionError    [CONTEXT]      if  (x  <  0  ||  x  >=  RADIX)  {  field.setIEEEFlagsBits(DfpField.FLAG_INVALID);  result  =  newInstance(getZero());  result.nans  =  QNAN;  result  =  dotrap(DfpField.FLAG_INVALID,  MULTIPLY_TRAP,  result,  result);  return  result;  }  int  rh  =  0;    [BUGGY]  int  mant  =  field.getField(DfpField.MAX_SCALE);  [BUGGY]    for  (int  i  =  0;  i  <  mant.length;  i++)  {  final  int  r  =  mant[i]  *  x  +  rh;  rh  =  r  /  RADIX;  result.mant[i]  =  r  -  rh  *  RADIX;  }  int  lostdigit  =  0;  if  (rh  !=  0)  {  lostdigit  =  result.mant[0];  result.shiftRight();  result.mant[mant.length-1]  =  rh;  [CLASS]  Dfp  [METHOD]  multiplyFast  [RETURN_TYPE]  Dfp  final  int  x  [VARIABLES]  boolean  byte  FINITE  INFINITE  QNAN  SNAN  asign  bsign  code  nans  rsign  sig  sign  x  DfpField  field  int[]  mant  product  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  fpdecimal  fpexp  s  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  adiff  aextradigit  bextradigit  decimalPos  diff  e  excp  exp  exponent  extra  i  j  lostdigit  md  n  offset  p  q  r  result  rh  rsize  sciexp  significantDigits  x  Dfp  result  	projects/Math17/src/main/java/org/apache/commons/math3/dfp/Dfp.java	0.7071067811865475	1644	1644	1	replace	int  mant  =  field.getField(DfpField.MAX_SCALE);	      int    mant    =    field.getField(DfpField.MAX_EXP);    	non-compiled	[CE]  illegal  start  of  type	4	None	replace
