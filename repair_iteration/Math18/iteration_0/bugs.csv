bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] break generationLoop; [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (max(diagD)/min(diagD) > 1e7) { break generationLoop; }  if (getConvergenceChecker() != null) { PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { [BUGGY] break generationLoop; [BUGGY] } lastResult = current; }  if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	
2	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (max(diagD)/min(diagD) > 1e7) { break generationLoop; }  if (getConvergenceChecker() != null) { PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { [BUGGY] [BUGGY] break generationLoop; } lastResult = current; }  if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	add	
3	[BUG] [BUGGY] sigma = sigma * Math.exp(0.2+cs/damps); [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; } lastResult = current; }  if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { [BUGGY] sigma = sigma * Math.exp(0.2+cs/damps); [BUGGY] } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); }  push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	
4	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness); if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) { break generationLoop; } lastResult = current; }  if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) { [BUGGY] [BUGGY] sigma = sigma * Math.exp(0.2+cs/damps); } if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) { sigma = sigma * Math.exp(0.2+cs/damps); }  push(fitnessHistory,bestFitness); fitfun.setValueRange(worstFitness-bestFitness); if (generateStatistics) { statisticsSigmaHistory.add(sigma); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	
5	[BUG] [BUGGY] lambda = 4 + (int) (3. * Math.log(dimension)); [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] private void initializeCMA(double[] guess) { if (lambda <= 0) { [BUGGY] lambda = 4 + (int) (3. * Math.log(dimension)); [BUGGY] }  double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] initializeCMA [RETURN_TYPE] void  double[] guess [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD insigma pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps range sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX sumw sumwq value valueRange w worstFitness double[][] boundaries sigmaArray List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	
6	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] private void initializeCMA(double[] guess) { if (lambda <= 0) { [BUGGY] [BUGGY] lambda = 4 + (int) (3. * Math.log(dimension)); }  double[][] sigmaArray = new double[guess.length][1]; for (int i = 0; i < guess.length; i++) { final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i]; sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range; } RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false); sigma = max(insigma); // overall standard deviation  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] initializeCMA [RETURN_TYPE] void  double[] guess [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD insigma pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps range sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX sumw sumwq value valueRange w worstFitness double[][] boundaries sigmaArray List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	add	
7	[BUG] [BUGGY] negccov = negcovMax; [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv);  double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { [BUGGY] negccov = negcovMax; [BUGGY] } arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac)  .add(roneu)  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] updateCovariance [RETURN_TYPE] void  boolean hsig RealMatrix bestArx RealMatrix arz final int[] arindex RealMatrix xold [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C Cneg D arnorms arnormsInv arnormsReverse arnormsSorted arpos artmp arx arxk arz arzneg bestArx bestArz diagC diagD insigma pc ps roneu weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff negalphaold negccov negcovMax negminresidualvariance normps oldFac range sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX sumw sumwq value valueRange w worstFitness double[][] boundaries sigmaArray List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int[] arReverseIndex arindex idxInv idxReverse idxnorms int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	
8	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms); int[] idxReverse = reverse(idxnorms); RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse); arnorms = divide(arnormsReverse, arnormsSorted); int[] idxInv = inverse(idxnorms); RealMatrix arnormsInv = selectColumns(arnorms, idxInv);  double negcovMax = (1. - negminresidualvariance) / square(arnormsInv).multiply(weights).getEntry(0, 0); if (negccov > negcovMax) { [BUGGY] [BUGGY] negccov = negcovMax; } arzneg = times(arzneg, repmat(arnormsInv, dimension, 1)); RealMatrix artmp = BD.multiply(arzneg); RealMatrix Cneg = artmp.multiply(diag(weights)).multiply( artmp.transpose()); oldFac += negalphaold * negccov; C = C.scalarMultiply(oldFac)  .add(roneu)  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] updateCovariance [RETURN_TYPE] void  boolean hsig RealMatrix bestArx RealMatrix arz final int[] arindex RealMatrix xold [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C Cneg D arnorms arnormsInv arnormsReverse arnormsSorted arpos artmp arx arxk arz arzneg bestArx bestArz diagC diagD insigma pc ps roneu weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff negalphaold negccov negcovMax negminresidualvariance normps oldFac range sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX sumw sumwq value valueRange w worstFitness double[][] boundaries sigmaArray List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int[] arReverseIndex arindex idxInv idxReverse idxnorms int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	
9	[BUG] [BUGGY] this(0); [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer() { [BUGGY] this(0); [BUGGY] } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer()  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	
10	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer() { [BUGGY] [BUGGY] this(0); } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer()  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	add	
11	[BUG] [BUGGY] } [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer() { this(0); [BUGGY] } [BUGGY]  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer()  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	
12	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer() { this(0); [BUGGY] [BUGGY] } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer()  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	add	
13	[BUG] [BUGGY] this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS, DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer(int lambda) { [BUGGY] this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,       DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); [BUGGY] DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer(int)  int lambda [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	
14	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] public CMAESOptimizer(int lambda) { [BUGGY] [BUGGY] this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,       DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY, DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false); } [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] <init> [RETURN_TYPE] CMAESOptimizer(int)  int lambda [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics isActiveCMA isMinimize isRepairMode double[] fitnessHistory inputSigma RealMatrix B BD C D diagC diagD pc ps weights xmean double DEFAULT_STOPFITNESS cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize index iterations lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	add	
16	[BUG] [BUGGY] break generationLoop; [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] } for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { [BUGGY] break generationLoop; [BUGGY] } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; }  if (max(diagD)/min(diagD) > 1e7) { break generationLoop; }  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	
17	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] } for (int i = 0; i < dimension; i++) { if (sigma*sqrtDiagC[i] > stopTolUpX) { break generationLoop; } } double historyBest = min(fitnessHistory); double historyWorst = max(fitnessHistory); if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) { [BUGGY] [BUGGY] break generationLoop; } if (iterations > fitnessHistory.length && historyWorst-historyBest < stopTolHistFun) { break generationLoop; }  if (max(diagD)/min(diagD) > 1e7) { break generationLoop; }  [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] doOptimize [RETURN_TYPE] PointValuePair  [VARIABLES] TooManyEvaluationsException e boolean DEFAULT_ISACTIVECMA generateStatistics hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess inputSigma pcCol sqrtDiagC RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory FitnessFunction fitfun int[] arindex int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random PointValuePair current lastResult optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	
18	[BUG] [BUGGY] boundaries = new double[2][]; [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (hasInfiniteBounds) {   throw new MathUnsupportedOperationException(); } else {  [BUGGY] boundaries = new double[2][]; [BUGGY] boundaries[0] = lB; boundaries[1] = uB;  for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] checkParameters [RETURN_TYPE] void  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries NumberIsTooLargeException e List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	
19	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (hasInfiniteBounds) {   throw new MathUnsupportedOperationException(); } else {  [BUGGY] [BUGGY] boundaries = new double[2][]; boundaries[0] = lB; boundaries[1] = uB;  for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] checkParameters [RETURN_TYPE] void  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries NumberIsTooLargeException e List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	add	
20	[BUG] [BUGGY] boundaries[0] = lB; [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (hasInfiniteBounds) {   throw new MathUnsupportedOperationException(); } else {  boundaries = new double[2][]; [BUGGY] boundaries[0] = lB; [BUGGY] boundaries[1] = uB;  for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] checkParameters [RETURN_TYPE] void  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries NumberIsTooLargeException e List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	
21	[BUG] [BUGGY] [FE] AssertionError testFitAccuracyDependsOnBoundary [CONTEXT] if (hasInfiniteBounds) {   throw new MathUnsupportedOperationException(); } else {  boundaries = new double[2][]; [BUGGY] [BUGGY] boundaries[0] = lB; boundaries[1] = uB;  for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); [CLASS] CMAESOptimizer DoubleIndex FitnessFunction [METHOD] checkParameters [RETURN_TYPE] void  [VARIABLES] boolean DEFAULT_ISACTIVECMA generateStatistics hasFiniteBounds hasInfiniteBounds hsig isActiveCMA isMinimize isRepairMode double[] fitness fitnessHistory guess init inputSigma lB pcCol sqrtDiagC uB RealMatrix B BD C D arx arxk arz bestArx bestArz diagC diagD pc ps weights xmean xold zmean double DEFAULT_STOPFITNESS bestFitness bestValue cc ccov1 ccov1Sep ccovmu ccovmuSep chiN cs damps historyBest historyWorst logMu2 max mueff normps sigma stopFitness stopTolFun stopTolHistFun stopTolUpX stopTolX value valueRange worstFitness double[][] boundaries NumberIsTooLargeException e List statisticsDHistory statisticsFitnessHistory statisticsMeanHistory statisticsSigmaHistory int DEFAULT_CHECKFEASABLECOUNT DEFAULT_DIAGONALONLY DEFAULT_MAXITERATIONS checkFeasableCount diagonalOnly dimension historySize i index iterations k lambda maxIterations mu RandomGenerator DEFAULT_RANDOMGENERATOR random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	add	
