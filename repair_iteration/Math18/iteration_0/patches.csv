bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number
this_action1	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  Double.MAX_VALUE  :  Double.POSITIVE_INFINITY;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  Double.MAX_VALUE  :  Double.POSITIVE_INFINITY;  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  hasInfiniteBounds?  Double.MAX_VALUE  :  Double.POSITIVE_INFINITY;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
2	[BUG]  [BUGGY]    double[][]  lB  =  Double.MAX_VALUE;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  Double.MAX_VALUE;  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  Double.MAX_VALUE;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
3	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  hasInfiniteBounds;  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  hasInfiniteBounds;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
4	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  null;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  null;  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  null;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
5	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  BD.values();  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  BD.values();  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  BD.values();		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
12	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]  this(4);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	add	this(4);	this(0);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	9	1
13	[BUG]  [BUGGY]  this(4);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]  this(4);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	this(4);	this(0);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	9	1	replace
14	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]  this(5);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	add	this(5);	this(0);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	9	1
15	[BUG]  [BUGGY]  this(5);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]  this(5);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	this(5);	this(0);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	9	1	replace
23	[BUG]  [BUGGY]  borders  =  new  double[2][];  [CE]  cannot  find  symbol  borders  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]  borders  =  new  double[2][];  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	borders  =  new  double[2][];	boundaries  =  new  double[2][];  	non-compiled	[CE]  cannot  find  symbol  borders	18	None	replace
32	[BUG]  [BUGGY]  boundaries[0]  =  lB.length;  [CE]  incompatible  types  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]  boundaries[0]  =  lB.length;  [BUGGY]  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	boundaries[0]  =  lB.length;	boundaries[0]  =  lB;  	non-compiled	[CE]  incompatible  types	20	None	replace
33	[BUG]  [BUGGY]  boundaries[0]  =  pcCol;  [CE]  cannot  find  symbol  pcCol  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]  boundaries[0]  =  pcCol;  [BUGGY]  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	boundaries[0]  =  pcCol;	boundaries[0]  =  lB;  	non-compiled	[CE]  cannot  find  symbol  pcCol	20	None	replace
41	[BUG]  [BUGGY]    setStatistics(DEFAULT_STOPFITNESS);  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setStatistics(DEFAULT_STOPFITNESS);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setStatistics(DEFAULT_STOPFITNESS);		non-compiled	[CE]  cannot  find  symbol	12	None	add
42	[BUG]  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA);  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setStatistics(DEFAULT_ISACTIVECMA);		non-compiled	[CE]  cannot  find  symbol	12	None	add
43	[BUG]  [BUGGY]    setStatistics(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setStatistics(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setStatistics(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);		non-compiled	[CE]  cannot  find  symbol	12	None	add
44	[BUG]  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setStatistics(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);		non-compiled	[CE]  cannot  find  symbol	12	None	add
45	[BUG]  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA,  false);  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setStatistics(DEFAULT_ISACTIVECMA,  false);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setStatistics(DEFAULT_ISACTIVECMA,  false);		non-compiled	[CE]  cannot  find  symbol	12	None	add
51	[BUG]  [BUGGY]    BD  =  BD.multiply(arnormsInv,  dimension,  1);  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    BD  =  BD.multiply(arnormsInv,  dimension,  1);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    BD  =  BD.multiply(arnormsInv,  dimension,  1);		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
52	[BUG]  [BUGGY]    double  negcovMax  =  Math.max(negccov  -  negminresidualvariance);  [CE]  variable  negcovMax  is  already  defined  in  method  updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    double  negcovMax  =  Math.max(negccov  -  negminresidualvariance);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    double  negcovMax  =  Math.max(negccov  -  negminresidualvariance);		non-compiled	[CE]  variable  negcovMax  is  already  defined  in  method  updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)	8	None	add
53	[BUG]  [BUGGY]    double  negcovMax  =  Math.max(negccov,  negalphaold);  [CE]  variable  negcovMax  is  already  defined  in  method  updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    double  negcovMax  =  Math.max(negccov,  negalphaold);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    double  negcovMax  =  Math.max(negccov,  negalphaold);		non-compiled	[CE]  variable  negcovMax  is  already  defined  in  method  updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)	8	None	add
54	[BUG]  [BUGGY]    negcovMax  =  Math.max(negccov);  [CE]  no  suitable  method  found  for  max(double)  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    negcovMax  =  Math.max(negccov);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    negcovMax  =  Math.max(negccov);		non-compiled	[CE]  no  suitable  method  found  for  max(double)	8	None	add
55	[BUG]  [BUGGY]    BD  =  BD.multiply(arnormsInv,  dimension,  2);  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    BD  =  BD.multiply(arnormsInv,  dimension,  2);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    BD  =  BD.multiply(arnormsInv,  dimension,  2);		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
61	[BUG]  [BUGGY]  lambda  =  4  +(int)(3.  *  Math.log(guess));  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  +(int)(3.  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  +(int)(3.  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	5	None	replace
62	[BUG]  [BUGGY]  lambda  =  4  *(2.5  *  Math.log(dimension));  [CE]  possible  loss  of  precision  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  *(2.5  *  Math.log(dimension));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  *(2.5  *  Math.log(dimension));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  possible  loss  of  precision	5	None	replace
63	[BUG]  [BUGGY]  lambda  =  4  +(int)(3).  *  Math.log(guess));  [CE]  <identifier>  expected  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  +(int)(3).  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  +(int)(3).  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  <identifier>  expected	5	None	replace
64	[BUG]  [BUGGY]  lambda  =  4  *(3.  *  Math.log(dimension));  [CE]  possible  loss  of  precision  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  *(3.  *  Math.log(dimension));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  *(3.  *  Math.log(dimension));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  possible  loss  of  precision	5	None	replace
71	[BUG]  [BUGGY]  break  result;  [CE]  undefined  label:  result  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]  break  result;  [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	break  result;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  result	1	None	replace
72	[BUG]  [BUGGY]  break  resultLoop;  [CE]  undefined  label:  resultLoop  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]  break  resultLoop;  [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	break  resultLoop;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  resultLoop	1	None	replace
74	[BUG]  [BUGGY]  break  symbda;  [CE]  undefined  label:  symbda  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]  break  symbda;  [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	break  symbda;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  symbda	1	None	replace
75	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	add	  	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	1	1
76	[BUG]  [BUGGY]    [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	  	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	1	1	replace
81	[BUG]  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  false);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,double,RandomGenerator,boolean)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  false);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  false);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,double,RandomGenerator,boolean)	14	None	add
82	[BUG]  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  true);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,double,RandomGenerator,boolean)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  true);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR,  true);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,double,RandomGenerator,boolean)	14	None	add
83	[BUG]  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  false);  [CE]  cannot  find  symbol  DEFAULT_DEFAGONALONLY  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  false);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  false);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_DEFAGONALONLY	14	None	add
84	[BUG]  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  false);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,boolean)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  false);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  false);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,boolean)	14	None	add
85	[BUG]  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  true);  [CE]  cannot  find  symbol  DEFAULT_DEFAGONALONLY  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  true);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_DEFAGONALONLY,  DEFAULT_RANDOMGENERATOR,  true);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_DEFAGONALONLY	14	None	add
91	[BUG]  [BUGGY]    double[][]  lB  =  Double.POSITIVE_INFINITY;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  Double.POSITIVE_INFINITY;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  Double.POSITIVE_INFINITY;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
92	[BUG]  [BUGGY]    double[][]  lB  =  Double.MAX_VALUE;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  Double.MAX_VALUE;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  Double.MAX_VALUE;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
93	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  hasInfiniteBounds;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  hasInfiniteBounds;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
94	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  pcCol;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  pcCol;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  pcCol;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
95	[BUG]  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  uB;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  uB;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  hasInfiniteBounds?  DEFAULT_STOPFITNESS  :  uB;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
101	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps  +  1);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	sigma  =  sigma  *  Math.exp(0.2+cs/damps  +  1);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1
102	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps  +  1);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps  +  1);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.2+cs/damps  +  1);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1	replace
103	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.5+cs/damps);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	sigma  =  sigma  *  Math.exp(0.5+cs/damps);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1
104	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.5+cs/damps);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.5+cs/damps);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.5+cs/damps);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1	replace
104	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps,  1);  [CE]  method  exp  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps,  1);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.2+cs/damps,  1);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  method  exp  in  class  Math  cannot  be  applied  to  given  types;	3	None	replace
105	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	  	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1
106	[BUG]  [BUGGY]    [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	  	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1	replace
111	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,boolean,int,int,boolean)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,boolean,int,int,boolean)	13	None	replace
112	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,double,int,int,boolean)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  false);	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(int,<null>,int,RandomGenerator,double,int,int,boolean)	13	None	replace
113	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
114	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_  [CE]  ')'  expected  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  ')'  expected	13	None	replace
122	[BUG]  [BUGGY]  break  bestFitness;  [CE]  undefined  label:  bestFitness  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  break  bestFitness;  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	break  bestFitness;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  bestFitness	16	None	replace
123	[BUG]  [BUGGY]  break  sigmaLoop;  [CE]  undefined  label:  sigmaLoop  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  break  sigmaLoop;  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	break  sigmaLoop;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  sigmaLoop	16	None	replace
124	[BUG]  [BUGGY]  break  historyLoop;  [CE]  undefined  label:  historyLoop  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  break  historyLoop;  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	break  historyLoop;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  historyLoop	16	None	replace
125	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	  	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
126	[BUG]  [BUGGY]    [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	  	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
131	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  guess);  [CE]  no  suitable  method  found  for  max(int,double[])  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  guess);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(lambda,  guess);		non-compiled	[CE]  no  suitable  method  found  for  max(int,double[])	6	None	add
132	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.exp(-lambda);  [CE]  incompatible  types  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.exp(-lambda);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.exp(-lambda);		non-compiled	[CE]  incompatible  types	6	None	add
133	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  false);  [CE]  no  suitable  method  found  for  max(int,boolean)  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  false);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(lambda,  false);		non-compiled	[CE]  no  suitable  method  found  for  max(int,boolean)	6	None	add
134	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(lambda);  [CE]  no  suitable  method  found  for  max(int)  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(lambda);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(lambda);		non-compiled	[CE]  no  suitable  method  found  for  max(int)	6	None	add
135	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  new  double[guess.length][0];  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	add	    double[][]  boundaries  =  new  double[guess.length][0];		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	6	1
136	[BUG]  [BUGGY]    double[][]  boundaries  =  new  double[guess.length][0];  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  new  double[guess.length][0];  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  new  double[guess.length][0];		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	6	1	add
141	[BUG]  [BUGGY]    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  bestFitness)-  stopTolFun);  [CE]  ';'  expected  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  bestFitness)-  stopTolFun);  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  bestFitness)-  stopTolFun);		non-compiled	[CE]  ';'  expected	17	None	add
142	[BUG]  [BUGGY]    double  diagD  =  Math.min(historyWorst,  bestFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);  [CE]  ';'  expected  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    double  diagD  =  Math.min(historyWorst,  bestFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    double  diagD  =  Math.min(historyWorst,  bestFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);		non-compiled	[CE]  ';'  expected	17	None	add
143	[BUG]  [BUGGY]    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);  [CE]  ';'  expected  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    double  diagD  =  Math.min(historyWorst,  worstFitness)-  Math.max(historyWorst,  worstFitness)-  stopTolFun);		non-compiled	[CE]  ';'  expected	17	None	add
151	[BUG]  [BUGGY]    super();  [CE]  call  to  this  must  be  first  statement  in  constructor  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    super();  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    super();		non-compiled	[CE]  call  to  this  must  be  first  statement  in  constructor	10	None	add
152	[BUG]  [BUGGY]    this(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(double,RandomGenerator)  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_STOPFITNESS,  DEFAULT_RANDOMGENERATOR);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(double,RandomGenerator)	10	None	add
153	[BUG]  [BUGGY]    this(DEFAULT_STOPFITNESS);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(double)  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_STOPFITNESS);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_STOPFITNESS);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(double)	10	None	add
154	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean,RandomGenerator)  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA,  DEFAULT_RANDOMGENERATOR);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean,RandomGenerator)	10	None	add
155	[BUG]  [BUGGY]    Preconditions.checkNotNull(DEFAULT_STOPFITNESS);  [CE]  cannot  find  symbol  Preconditions  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    Preconditions.checkNotNull(DEFAULT_STOPFITNESS);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    Preconditions.checkNotNull(DEFAULT_STOPFITNESS);		non-compiled	[CE]  cannot  find  symbol  Preconditions	10	None	add
161	[BUG]  [BUGGY]    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  break  generationLoop;  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  break  generationLoop;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  break  generationLoop;  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
162	[BUG]  [BUGGY]    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(isActiveCMA)  {  break  generationLoop;  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(isActiveCMA)  {  break  generationLoop;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(isActiveCMA)  {  break  generationLoop;  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
163	[BUG]  [BUGGY]    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(!isActiveCMA)  {  break  generationLoop;  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(!isActiveCMA)  {  break  generationLoop;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(bestFitness  >  bestArx.getColumnCount()  -  1)  {  if(!isActiveCMA)  {  break  generationLoop;  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
164	[BUG]  [BUGGY]    if(bestFitness  >  bestArx)  {  if(isActiveCMA)  {  break  generationLoop;  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(bestFitness  >  bestArx)  {  if(isActiveCMA)  {  break  generationLoop;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(bestFitness  >  bestArx)  {  if(isActiveCMA)  {  break  generationLoop;  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
165	[BUG]  [BUGGY]    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  generateStatistics;  }  [CE]  not  a  statement  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  generateStatistics;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(bestFitness  >  bestArx.getColumnSize())  {  if(isActiveCMA)  {  generateStatistics;  }		non-compiled	[CE]  not  a  statement	4	None	add
172	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =  negcovMax  -  1;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	negccov  =  negcovMax  -  1;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1
173	[BUG]  [BUGGY]  negccov  =  negcovMax  -  1;  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =  negcovMax  -  1;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  =  negcovMax  -  1;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1	replace
173	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  -=  negcovMax;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	negccov  -=  negcovMax;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1
174	[BUG]  [BUGGY]  negccov  -=  negcovMax;  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  -=  negcovMax;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  -=  negcovMax;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1	replace
174	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =  0;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	negccov  =  0;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1
175	[BUG]  [BUGGY]  negccov  =  0;  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =  0;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  =  0;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1	replace
183	[BUG]  [BUGGY]  this.statisticsMeanHistory  =  getStatisticsMean();  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  this.statisticsMeanHistory  =  getStatisticsMean();  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	this.statisticsMeanHistory  =  getStatisticsMean();	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
191	[BUG]  [BUGGY]    bestFitness  =  Math.max(bestArx.getColumn(1),  isMinimize?  bestFitness  :  -bestFitness);  [CE]  no  suitable  method  found  for  max(double[],double)  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    bestFitness  =  Math.max(bestArx.getColumn(1),  isMinimize?  bestFitness  :  -bestFitness);  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    bestFitness  =  Math.max(bestArx.getColumn(1),  isMinimize?  bestFitness  :  -bestFitness);		non-compiled	[CE]  no  suitable  method  found  for  max(double[],double)	2	None	add
192	[BUG]  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getCharno());  [CE]  not  a  statement  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getCharno());  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    isRepairMode?  bestArx.getLineno()  :  bestArx.getCharno());		non-compiled	[CE]  not  a  statement	2	None	add
193	[BUG]  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNumber(1);  [CE]  not  a  statement  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNumber(1);  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNumber(1);		non-compiled	[CE]  not  a  statement	2	None	add
194	[BUG]  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode());  [CE]  not  a  statement  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode());  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode());		non-compiled	[CE]  not  a  statement	2	None	add
195	[BUG]  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode();  [CE]  not  a  statement  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode();  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    isRepairMode?  bestArx.getLineno()  :  bestArx.getColumnNode();		non-compiled	[CE]  not  a  statement	2	None	add
2	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean)  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean)	10	None	add
3	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);  [CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean,int)  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);		non-compiled	[CE]  no  suitable  constructor  found  for  CMAESOptimizer(boolean,int)	10	None	add
4	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAMES);  [CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAMES);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAMES);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES	10	None	add
5	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAME);  [CE]  cannot  find  symbol  DEFAULT_FIELD_NAME  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAME);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA,  DEFAULT_FIELD_NAME);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_FIELD_NAME	10	None	add
24	[BUG]  [BUGGY]  borders  =  new  double[0][];  [CE]  cannot  find  symbol  borders  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]  borders  =  new  double[0][];  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	borders  =  new  double[0][];	boundaries  =  new  double[2][];  	non-compiled	[CE]  cannot  find  symbol  borders	18	None	replace
41	[BUG]  [BUGGY]  this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	this(DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
42	[BUG]  [BUGGY]  setFixedOptimizer(DEFAULT_ISACTIVECMA);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  setFixedOptimizer(DEFAULT_ISACTIVECMA);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	setFixedOptimizer(DEFAULT_ISACTIVECMA);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
43	[BUG]  [BUGGY]  setFixedOptimizer(new  DoubleInputStreamReader());  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  setFixedOptimizer(new  DoubleInputStreamReader());  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	setFixedOptimizer(new  DoubleInputStreamReader());	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
44	[BUG]  [BUGGY]  this(DEFAULT_ISACTIVECMA);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  this(DEFAULT_ISACTIVECMA);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	this(DEFAULT_ISACTIVECMA);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
62	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.abs(lambda);  [CE]  incompatible  types  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.abs(lambda);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.abs(lambda);		non-compiled	[CE]  incompatible  types	6	None	add
63	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.exp(Math.abs(lambda));  [CE]  incompatible  types  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.exp(Math.abs(lambda));  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.exp(Math.abs(lambda));		non-compiled	[CE]  incompatible  types	6	None	add
64	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.exp(getBounds());  [CE]  cannot  find  symbol  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.exp(getBounds());  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.exp(getBounds());		non-compiled	[CE]  cannot  find  symbol	6	None	add
65	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  0);  [CE]  incompatible  types  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(lambda,  0);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(lambda,  0);		non-compiled	[CE]  incompatible  types	6	None	add
101	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  [CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES	13	None	replace
103	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
104	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR  [CE]  ')'  expected  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_FIELD_NAMES,  DEFAULT_COUNT,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  ')'  expected	13	None	replace
121	[BUG]  [BUGGY]    double[][]  lB  =  getBinaryValues();  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  getBinaryValues();  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  getBinaryValues();		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
122	[BUG]  [BUGGY]    double[][]  lB  =  getBounds();  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  getBounds();  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  getBounds();		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
123	[BUG]  [BUGGY]    double[][]  lB  =  Double.valueOf(null);  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  Double.valueOf(null);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  Double.valueOf(null);		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
124	[BUG]  [BUGGY]    double[][]  lB  =  getBinaryValue(null);  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  getBinaryValue(null);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  getBinaryValue(null);		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
125	[BUG]  [BUGGY]    double[][]  lB  =  getBinaryValue(cs);  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  getBinaryValue(cs);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  getBinaryValue(cs);		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
142	[BUG]  [BUGGY]  break  pointValuePair;  [CE]  undefined  label:  pointValuePair  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]  break  pointValuePair;  [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	break  pointValuePair;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  pointValuePair	1	None	replace
144	[BUG]  [BUGGY]  break  resultIndent;  [CE]  undefined  label:  resultIndent  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]  break  resultIndent;  [BUGGY]  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	break  resultIndent;	break  generationLoop;  	non-compiled	[CE]  undefined  label:  resultIndent	1	None	replace
161	[BUG]  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv,  xold);  BD  =  BD.multiply(arnormsInv,  xold);  }  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv,  xold);  BD  =  BD.multiply(arnormsInv,  xold);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv,  xold);  BD  =  BD.multiply(arnormsInv,  xold);  }		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
162	[BUG]  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
163	[BUG]  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  xold);  }  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  xold);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsInv  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  xold);  }		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
164	[BUG]  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }  [CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsInv);  BD  =  BD.multiply(arnormsInv,  negalphaold);  }		non-compiled	[CE]  method  multiply  in  interface  RealMatrix  cannot  be  applied  to  given  types;	8	None	add
165	[BUG]  [BUGGY]    negcovMax  =  Math.max(negccov  -  bestArx,  worstArx);  [CE]  bad  operand  types  for  binary  operator  '-'  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    negcovMax  =  Math.max(negccov  -  bestArx,  worstArx);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    negcovMax  =  Math.max(negccov  -  bestArx,  worstArx);		non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	8	None	add
182	[BUG]  [BUGGY]  lambda  =  256  +(int)(.  *  Math.log(guess));  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  256  +(int)(.  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  256  +(int)(.  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  illegal  start  of  expression	5	None	replace
183	[BUG]  [BUGGY]  lambda  =  0.5  +(int)(.  *  Math.log(guess.length));  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  0.5  +(int)(.  *  Math.log(guess.length));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  0.5  +(int)(.  *  Math.log(guess.length));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  illegal  start  of  expression	5	None	replace
184	[BUG]  [BUGGY]  lambda  =  256  +(int)(3.  *  Math.log(guess));  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  256  +(int)(3.  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  256  +(int)(3.  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	5	None	replace
201	[BUG]  [BUGGY]    super();  [CE]  call  to  this  must  be  first  statement  in  constructor  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    super();  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    super();		non-compiled	[CE]  call  to  this  must  be  first  statement  in  constructor	14	None	add
202	[BUG]  [BUGGY]    super(lambda);  [CE]  no  suitable  constructor  found  for  BaseAbstractMultivariateSimpleBoundsOptimizer(int)  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    super(lambda);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    super(lambda);		non-compiled	[CE]  no  suitable  constructor  found  for  BaseAbstractMultivariateSimpleBoundsOptimizer(int)	14	None	add
203	[BUG]  [BUGGY]    Preconditions.checkArgument(lambda!=  0);  [CE]  cannot  find  symbol  Preconditions  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    Preconditions.checkArgument(lambda!=  0);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    Preconditions.checkArgument(lambda!=  0);		non-compiled	[CE]  cannot  find  symbol  Preconditions	14	None	add
204	[BUG]  [BUGGY]    Preconditions.checkArgument(lambda  >=  0);  [CE]  cannot  find  symbol  Preconditions  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    Preconditions.checkArgument(lambda  >=  0);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    Preconditions.checkArgument(lambda  >=  0);		non-compiled	[CE]  cannot  find  symbol  Preconditions	14	None	add
205	[BUG]  [BUGGY]    Preconditions.checkArgument(lambda  ==  0);  [CE]  cannot  find  symbol  Preconditions  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    Preconditions.checkArgument(lambda  ==  0);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    Preconditions.checkArgument(lambda  ==  0);		non-compiled	[CE]  cannot  find  symbol  Preconditions	14	None	add
221	[BUG]  [BUGGY]  if(historyWorst  ==  null)  {  break  generationLoop;  }  [CE]  incomparable  types:  double  and  <null>  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  null)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(historyWorst  ==  null)  {  break  generationLoop;  }	break  generationLoop;  	non-compiled	[CE]  incomparable  types:  double  and  <null>	16	None	replace
222	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0.0)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(historyWorst  ==  0.0)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
223	[BUG]  [BUGGY]  if(historyWorst  ==  0.0)  {  break  generationLoop;  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0.0)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(historyWorst  ==  0.0)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
223	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(historyWorst  ==  0)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
224	[BUG]  [BUGGY]  if(historyWorst  ==  0)  {  break  generationLoop;  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(historyWorst  ==  0)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
224	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0.5)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(historyWorst  ==  0.5)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
225	[BUG]  [BUGGY]  if(historyWorst  ==  0.5)  {  break  generationLoop;  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(historyWorst  ==  0.5)  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(historyWorst  ==  0.5)  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
241	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  continue;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  continue;  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  continue;  }		non-compiled	[CE]  illegal  start  of  expression	17	None	add
242	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  throw  new  IllegalArgumentException( " ");  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    for(int  i  =  0;  i  <  dimension;  i++)  {  if(historyWorst  ==  historyWorst)  {  throw  new  IllegalArgumentException( " ");  }		non-compiled	[CE]  illegal  start  of  expression	17	None	add
243	[BUG]  [BUGGY]    double  diagD  =  historyWorst.doubleValue();  [CE]  double  cannot  be  dereferenced  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    double  diagD  =  historyWorst.doubleValue();  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    double  diagD  =  historyWorst.doubleValue();		non-compiled	[CE]  double  cannot  be  dereferenced	17	None	add
244	[BUG]  [BUGGY]    double  diagD  =  getFieldType(historyWorst);  [CE]  cannot  find  symbol  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    double  diagD  =  getFieldType(historyWorst);  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    double  diagD  =  getFieldType(historyWorst);		non-compiled	[CE]  cannot  find  symbol	17	None	add
245	[BUG]  [BUGGY]    if(historyWorst  ==  null)  {  if(historyWorst  ==  historyWorst)  {  continue;  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(historyWorst  ==  null)  {  if(historyWorst  ==  historyWorst)  {  continue;  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(historyWorst  ==  null)  {  if(historyWorst  ==  historyWorst)  {  continue;  }		non-compiled	[CE]  illegal  start  of  expression	17	None	add
263	[BUG]  [BUGGY]  borders[0]  =  lB;  [CE]  cannot  find  symbol  borders  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]  borders[0]  =  lB;  [BUGGY]  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	borders[0]  =  lB;	boundaries[0]  =  lB;  	non-compiled	[CE]  cannot  find  symbol  borders	20	None	replace
284	[BUG]  [BUGGY]    setFieldOptimizer(DEFAULT_FIELD_NAMES);  [CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setFieldOptimizer(DEFAULT_FIELD_NAMES);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setFieldOptimizer(DEFAULT_FIELD_NAMES);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_FIELD_NAMES	12	None	add
285	[BUG]  [BUGGY]    setFieldOptimizer(DEFAULT_FIELD_NAME);  [CE]  cannot  find  symbol  DEFAULT_FIELD_NAME  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setFieldOptimizer(DEFAULT_FIELD_NAME);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setFieldOptimizer(DEFAULT_FIELD_NAME);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_FIELD_NAME	12	None	add
303	[BUG]  [BUGGY]  negccov  =(negcovMax  -  negminresidualvariance));  [CE]  ';'  expected  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =(negcovMax  -  negminresidualvariance));  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  =(negcovMax  -  negminresidualvariance));	negccov  =  negcovMax;  	non-compiled	[CE]  ';'  expected	7	None	replace
304	[BUG]  [BUGGY]  negccov  =(negcovMax  *  negminresidualvariance)?  negcovMax  :  negcovMax;  [CE]  incompatible  types  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =(negcovMax  *  negminresidualvariance)?  negcovMax  :  negcovMax;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  =(negcovMax  *  negminresidualvariance)?  negcovMax  :  negcovMax;	negccov  =  negcovMax;  	non-compiled	[CE]  incompatible  types	7	None	replace
321	[BUG]  [BUGGY]    if(generateStatistics)  {  if(bestFitness  >  bestFitness)  {  throw  new  IllegalArgumentException( " ");  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(generateStatistics)  {  if(bestFitness  >  bestFitness)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(generateStatistics)  {  if(bestFitness  >  bestFitness)  {  throw  new  IllegalArgumentException( " ");  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
322	[BUG]  [BUGGY]    if(generateStatistics)  {  if(bestFitness  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(generateStatistics)  {  if(bestFitness  ==  null)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(generateStatistics)  {  if(bestFitness  ==  null)  {  throw  new  IllegalArgumentException( " ");  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
324	[BUG]  [BUGGY]    int[]  dups  =  getDimensions();  [CE]  cannot  find  symbol  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    int[]  dups  =  getDimensions();  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    int[]  dups  =  getDimensions();		non-compiled	[CE]  cannot  find  symbol	4	None	add
325	[BUG]  [BUGGY]    if(generateStatistics)  {  if(bestFitness  ==  null)  {  return;  }  [CE]  illegal  start  of  expression  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    if(generateStatistics)  {  if(bestFitness  ==  null)  {  return;  }  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    if(generateStatistics)  {  if(bestFitness  ==  null)  {  return;  }		non-compiled	[CE]  illegal  start  of  expression	4	None	add
341	[BUG]  [BUGGY]    bestArx  =  current.getArx();  [CE]  cannot  find  symbol  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    bestArx  =  current.getArx();  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    bestArx  =  current.getArx();		non-compiled	[CE]  cannot  find  symbol	2	None	add
342	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(current,  bestArx));  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(current,  bestArx));  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(current,  bestArx));		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
343	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  current));  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  current));  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(bestArx,  current));		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
344	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(current,  bestArx),  isMinimize);  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(current,  bestArx),  isMinimize);  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(current,  bestArx),  isMinimize);		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
345	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  bestFitness));  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  bestFitness));  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(bestArx,  bestFitness));		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
361	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(!hasInfiniteBounds)  {  throw  new  MathUnsupportedOperationException( " ");  }  [CE]  'else'  without  'if'  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(!hasInfiniteBounds)  {  throw  new  MathUnsupportedOperationException( " ");  }  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(!hasInfiniteBounds)  {  throw  new  MathUnsupportedOperationException( " ");  }		non-compiled	[CE]  'else'  without  'if'	21	None	add
362	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( " ");  }  [CE]  'else'  without  'if'  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( " ");  }  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( " ");  }		non-compiled	[CE]  'else'  without  'if'	21	None	add
363	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0],  uB))  {  throw  new  MathUnsupportedOperationException( " ");  }  [CE]  'else'  without  'if'  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0],  uB))  {  throw  new  MathUnsupportedOperationException( " ");  }  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0],  uB))  {  throw  new  MathUnsupportedOperationException( " ");  }		non-compiled	[CE]  'else'  without  'if'	21	None	add
364	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  return;  }  [CE]  'else'  without  'if'  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  return;  }  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  return;  }		non-compiled	[CE]  'else'  without  'if'	21	None	add
365	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( ") ");  }  [CE]  'else'  without  'if'  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( ") ");  }  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    for(int  i  =  0;  i  <  boundaries.length;  i++)  {  if(Double.isInfinite(boundaries[0][i]))  {  throw  new  MathUnsupportedOperationException( ") ");  }		non-compiled	[CE]  'else'  without  'if'	21	None	add
381	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/damps);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	sigma  =  sigma  *  Math.exp(1.0+cs/damps);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1
382	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/damps);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/damps);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(1.0+cs/damps);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	3	1	replace
382	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/dups);  [CE]  cannot  find  symbol  dups  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/dups);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(1.0+cs/dups);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  dups	3	None	replace
383	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/duplicate);  [CE]  cannot  find  symbol  duplicate  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(1.0+cs/duplicate);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(1.0+cs/duplicate);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  duplicate	3	None	replace
384	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(2.0+cs/dups);  [CE]  cannot  find  symbol  dups  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(2.0+cs/dups);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(2.0+cs/dups);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  dups	3	None	replace
3	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLE  [CE]  ')'  expected  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLE  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLE	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  ')'  expected	13	None	replace
4	[BUG]  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFE  [CE]  ')'  expected  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFE  [BUGGY]  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_RANDOMGENERATOR,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFE	this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,    DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  	non-compiled	[CE]  ')'  expected	13	None	replace
31	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/dups);  [CE]  cannot  find  symbol  dups  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/dups);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.2+cs/dups);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  dups	3	None	replace
33	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/da/4);  [CE]  cannot  find  symbol  da  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/da/4);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.2+cs/da/4);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  da	3	None	replace
34	[BUG]  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/da);  [CE]  cannot  find  symbol  da  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/da);  [BUGGY]  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	sigma  =  sigma  *  Math.exp(0.2+cs/da);	sigma  =  sigma  *  Math.exp(0.2+cs/damps);  	non-compiled	[CE]  cannot  find  symbol  da	3	None	replace
64	[BUG]  [BUGGY]  this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR);  [CE]  cannot  find  symbol  DEFAULT_LOAD_FACTOR  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]  this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR);  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR);	this(0);  	non-compiled	[CE]  cannot  find  symbol  DEFAULT_LOAD_FACTOR	9	None	replace
91	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
92	[BUG]  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
92	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
93	[BUG]  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(bestFitness  <=  Math.min(historyWorst,  bestFitness))  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
93	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
94	[BUG]  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalArgumentException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
94	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalStateException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	add	if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalStateException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1
95	[BUG]  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalStateException( " ");  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]  if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalStateException( " ");  }  [BUGGY]  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	if(bestFitness  <=  historyWorst)  {  break  generationLoop;  }  else  {  throw  new  IllegalStateException( " ");  }	break  generationLoop;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	16	1	replace
121	[BUG]  [BUGGY]  setFixedOptimizer(getAutoRangeStickyZero());  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  setFixedOptimizer(getAutoRangeStickyZero());  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	setFixedOptimizer(getAutoRangeStickyZero());	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
122	[BUG]  [BUGGY]  return  new  CMAESOptimizer(this,  false);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  return  new  CMAESOptimizer(this,  false);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	return  new  CMAESOptimizer(this,  false);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
123	[BUG]  [BUGGY]  return  new  CMAESOptimizer(this,  true);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  return  new  CMAESOptimizer(this,  true);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	return  new  CMAESOptimizer(this,  true);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
124	[BUG]  [BUGGY]  return  new  CMAESOptimizer(this);  [CE]  illegal  start  of  expression  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]  return  new  CMAESOptimizer(this);  [BUGGY]    [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	return  new  CMAESOptimizer(this);	}  	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
151	[BUG]  [BUGGY]    double[][]  boundaries  =  getBounds();  [CE]  cannot  find  symbol  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  boundaries  =  getBounds();  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  boundaries  =  getBounds();		non-compiled	[CE]  cannot  find  symbol	19	None	add
152	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  uB);  [CE]  no  suitable  method  found  for  max(double[],double[])  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  uB);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  boundaries  =  Math.max(boundaries[0],  uB);		non-compiled	[CE]  no  suitable  method  found  for  max(double[],double[])	19	None	add
153	[BUG]  [BUGGY]    double  lB  =  Double.MAX_VALUE;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double  lB  =  Double.MAX_VALUE;  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double  lB  =  Double.MAX_VALUE;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
154	[BUG]  [BUGGY]    double[][]  lB  =  Double.valueOf(uB);  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  lB  =  Double.valueOf(uB);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  lB  =  Double.valueOf(uB);		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	19	None	add
155	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  0);  [CE]  no  suitable  method  found  for  max(double[],int)  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  0);  [BUGGY]  boundaries  =  new  double[2][];  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	    double[][]  boundaries  =  Math.max(boundaries[0],  0);		non-compiled	[CE]  no  suitable  method  found  for  max(double[],int)	19	None	add
181	[BUG]  [BUGGY]  lambda  =  4  +(int)(0.5  *  Math.log(guess));  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  +(int)(0.5  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  +(int)(0.5  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	5	None	replace
183	[BUG]  [BUGGY]  lambda  =  3  +(int)  (3.  *  Math.log(guess));  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  3  +(int)  (3.  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  3  +(int)  (3.  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	5	None	replace
184	[BUG]  [BUGGY]  lambda  =  4  +(int)(2.5  *  Math.log(guess));  [CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]  lambda  =  4  +(int)(2.5  *  Math.log(guess));  [BUGGY]  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	lambda  =  4  +(int)(2.5  *  Math.log(guess));	lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  	non-compiled	[CE]  method  log  in  class  Math  cannot  be  applied  to  given  types;	5	None	replace
212	[BUG]  [BUGGY]    double  lB  =  Double.MAX_VALUE;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double  lB  =  Double.MAX_VALUE;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double  lB  =  Double.MAX_VALUE;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
213	[BUG]  [BUGGY]    double[][]  lB  =  Double.NaN;  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  Double.NaN;  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  Double.NaN;		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
214	[BUG]  [BUGGY]    double[][]  lB  =  Double.valueOf(isInfinite());  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  Double.valueOf(isInfinite());  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  Double.valueOf(isInfinite());		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
215	[BUG]  [BUGGY]    double[][]  lB  =  Double.valueOf(uB);  [CE]  variable  lB  is  already  defined  in  method  checkParameters()  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]    double[][]  lB  =  Double.valueOf(uB);  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	    double[][]  lB  =  Double.valueOf(uB);		non-compiled	[CE]  variable  lB  is  already  defined  in  method  checkParameters()	21	None	add
241	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1
242	[BUG]  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted);  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1	add
243	[BUG]  [BUGGY]    bestArx  =  BD.multiply(arnormsInv);  [CE]  final  parameter  bestArx  may  not  be  assigned  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    bestArx  =  BD.multiply(arnormsInv);  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    bestArx  =  BD.multiply(arnormsInv);		non-compiled	[CE]  final  parameter  bestArx  may  not  be  assigned	8	None	add
244	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsInv);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsInv);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1
245	[BUG]  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsInv);  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsInv);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsInv);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1	add
245	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsSorted);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsSorted);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1
246	[BUG]  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsSorted);  }  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsSorted);  }  [BUGGY]  negccov  =  negcovMax;  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	    if(arnormsSorted  ==  null)  {  BD  =  BD.multiply(arnormsSorted);  BD  =  BD.multiply(arnormsSorted).multiply(arnormsSorted);  }		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	8	1	add
271	[BUG]  [BUGGY]    current.setOptionalArg(true);  [CE]  cannot  find  symbol  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.setOptionalArg(true);  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.setOptionalArg(true);		non-compiled	[CE]  cannot  find  symbol	2	None	add
273	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  fitness));  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  fitness));  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(bestArx,  fitness));		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
275	[BUG]  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  current),  isMinimize);  [CE]  cannot  find  symbol  FieldUtils  [CONTEXT]  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  if  (getConvergenceChecker()  !=  null)  {  PointValuePair  current  =  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  [BUGGY]    current.addLast(FieldUtils.safeMultiply(bestArx,  current),  isMinimize);  [BUGGY]  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	476	476	1	replace	    current.addLast(FieldUtils.safeMultiply(bestArx,  current),  isMinimize);		non-compiled	[CE]  cannot  find  symbol  FieldUtils	2	None	add
302	[BUG]  [BUGGY]    setFixedOptimizer(getAutoRangeStickyZero());  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    setFixedOptimizer(getAutoRangeStickyZero());  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    setFixedOptimizer(getAutoRangeStickyZero());		non-compiled	[CE]  cannot  find  symbol	10	None	add
303	[BUG]  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR,  false);  [CE]  cannot  find  symbol  DEFAULT_LOAD_FACTOR  [CONTEXT]  public  CMAESOptimizer()  {  [BUGGY]    this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR,  false);  [BUGGY]  this(0);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	246	246	1	replace	    this(DEFAULT_ISACTIVECMA,  DEFAULT_LOAD_FACTOR,  false);		non-compiled	[CE]  cannot  find  symbol  DEFAULT_LOAD_FACTOR	10	None	add
334	[BUG]  [BUGGY]    setFixedOptimizer(getCrc());  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setFixedOptimizer(getCrc());  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setFixedOptimizer(getCrc());		non-compiled	[CE]  cannot  find  symbol	12	None	add
335	[BUG]  [BUGGY]    setFixedOptimizer(getAutoRangeStandardOptimizer());  [CE]  cannot  find  symbol  [CONTEXT]  public  CMAESOptimizer()  {  this(0);  [BUGGY]    setFixedOptimizer(getAutoRangeStandardOptimizer());  [BUGGY]  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer()  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	247	247	1	replace	    setFixedOptimizer(getAutoRangeStandardOptimizer());		non-compiled	[CE]  cannot  find  symbol	12	None	add
362	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]  boundaries  =  new  double[3][];  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	add	boundaries  =  new  double[3][];	boundaries  =  new  double[2][];  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	18	1
363	[BUG]  [BUGGY]  boundaries  =  new  double[3][];  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {    [BUGGY]  boundaries  =  new  double[3][];  [BUGGY]  boundaries[0]  =  lB;  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	535	535	1	replace	boundaries  =  new  double[3][];	boundaries  =  new  double[2][];  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	18	1	replace
392	[BUG]  [BUGGY]  boundaries[0]  =  i;  [CE]  cannot  find  symbol  i  [CONTEXT]  if  (hasInfiniteBounds)  {    throw  new  MathUnsupportedOperationException();  }  else  {  boundaries  =  new  double[2][];  [BUGGY]  boundaries[0]  =  i;  [BUGGY]  boundaries[1]  =  uB;  for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  checkParameters  [RETURN_TYPE]  void  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  NumberIsTooLargeException  e  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.4472135954999579	536	536	1	replace	boundaries[0]  =  i;	boundaries[0]  =  lB;  	non-compiled	[CE]  cannot  find  symbol  i	20	None	replace
421	[BUG]  [BUGGY]    if(bestFitness  >=  historyBest)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }  [CE]  not  a  statement  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(bestFitness  >=  historyBest)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(bestFitness  >=  historyBest)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }		non-compiled	[CE]  not  a  statement	17	None	add
422	[BUG]  [BUGGY]    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness])  {  stopTolHistFun;  }  [CE]  ')'  expected  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness])  {  stopTolHistFun;  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness])  {  stopTolHistFun;  }		non-compiled	[CE]  ')'  expected	17	None	add
423	[BUG]  [BUGGY]    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.sqrt(historyWorst);  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.sqrt(historyWorst);  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.sqrt(historyWorst);  }		non-compiled	[CE]  illegal  start  of  expression	17	None	add
424	[BUG]  [BUGGY]    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.abs(historyWorst);  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.abs(historyWorst);  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(historyWorst  ==  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun  =  Math.abs(historyWorst);  }		non-compiled	[CE]  illegal  start  of  expression	17	None	add
425	[BUG]  [BUGGY]    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }  [CE]  not  a  statement  [CONTEXT]  }  for  (int  i  =  0;  i  <  dimension;  i++)  {  if  (sigma*sqrtDiagC[i]  >  stopTolUpX)  {  break  generationLoop;  }  }  double  historyBest  =  min(fitnessHistory);  double  historyWorst  =  max(fitnessHistory);  if  (iterations  >  2  &&  Math.max(historyWorst,  worstFitness)  -  Math.min(historyBest,  bestFitness)  <  stopTolFun)  {  [BUGGY]    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }  [BUGGY]  break  generationLoop;  }  if  (iterations  >  fitnessHistory.length  &&  historyWorst-historyBest  <  stopTolHistFun)  {  break  generationLoop;  }  if  (max(diagD)/min(diagD)  >  1e7)  {  break  generationLoop;  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	459	459	1	replace	    if(bestFitness  >=  historyWorst)  {  if(sigma*sqrtDiagC[i]  ==  bestFitness)  {  stopTolHistFun;  }		non-compiled	[CE]  not  a  statement	17	None	add
483	[BUG]  [BUGGY]    Preconditions.checkArgument(lambda  <  0);  [CE]  cannot  find  symbol  Preconditions  [CONTEXT]  public  CMAESOptimizer(int  lambda)  {  [BUGGY]    Preconditions.checkArgument(lambda  <  0);  [BUGGY]  this(lambda,  null,  DEFAULT_MAXITERATIONS,  DEFAULT_STOPFITNESS,    DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,        DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  DEFAULT_ISACTIVECMA,  DEFAULT_DIAGONALONLY,  DEFAULT_CHECKFEASABLECOUNT,  DEFAULT_RANDOMGENERATOR,  false);  }  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  <init>  [RETURN_TYPE]  CMAESOptimizer(int)  int  lambda  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  isActiveCMA  isMinimize  isRepairMode  double[]  fitnessHistory  inputSigma  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  index  iterations  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.5773502691896258	253	255	1	replace	    Preconditions.checkArgument(lambda  <  0);		non-compiled	[CE]  cannot  find  symbol  Preconditions	14	None	add
511	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(math.length,  guess);  [CE]  cannot  find  symbol  math  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(math.length,  guess);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(math.length,  guess);		non-compiled	[CE]  cannot  find  symbol  math	6	None	add
512	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  0);  [CE]  no  suitable  method  found  for  max(double[],int)  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries[0],  0);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(boundaries[0],  0);		non-compiled	[CE]  no  suitable  method  found  for  max(double[],int)	6	None	add
513	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries,  guess);  [CE]  no  suitable  method  found  for  max(double[][],double[])  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries,  guess);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(boundaries,  guess);		non-compiled	[CE]  no  suitable  method  found  for  max(double[][],double[])	6	None	add
514	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries,  guess.length);  [CE]  no  suitable  method  found  for  max(double[][],int)  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(boundaries,  guess.length);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(boundaries,  guess.length);		non-compiled	[CE]  no  suitable  method  found  for  max(double[][],int)	6	None	add
515	[BUG]  [BUGGY]    double[][]  boundaries  =  Math.max(math.length,  0.5);  [CE]  cannot  find  symbol  math  [CONTEXT]  private  void  initializeCMA(double[]  guess)  {  if  (lambda  <=  0)  {  [BUGGY]    double[][]  boundaries  =  Math.max(math.length,  0.5);  [BUGGY]  lambda  =  4  +  (int)  (3.  *  Math.log(dimension));  }  double[][]  sigmaArray  =  new  double[guess.length][1];  for  (int  i  =  0;  i  <  guess.length;  i++)  {  final  double  range  =  (boundaries  ==  null)  ?  1.0  :  boundaries[1][i]  -  boundaries[0][i];  sigmaArray[i][0]  =  ((inputSigma  ==  null)  ?  0.3  :  inputSigma[i])  /  range;  }  RealMatrix  insigma  =  new  Array2DRowRealMatrix(sigmaArray,  false);  sigma  =  max(insigma);  //  overall  standard  deviation  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  initializeCMA  [RETURN_TYPE]  void  double[]  guess  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  insigma  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  normps  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	583	583	1	replace	    double[][]  boundaries  =  Math.max(math.length,  0.5);		non-compiled	[CE]  cannot  find  symbol  math	6	None	add
544	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =(negccov  >  0)?  negcovMax  :  negminresidualvariance;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	add	negccov  =(negccov  >  0)?  negcovMax  :  negminresidualvariance;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1
545	[BUG]  [BUGGY]  negccov  =(negccov  >  0)?  negcovMax  :  negminresidualvariance;  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  RealMatrix  arnormsSorted  =  selectColumns(arnorms,  idxnorms);  int[]  idxReverse  =  reverse(idxnorms);  RealMatrix  arnormsReverse  =  selectColumns(arnorms,  idxReverse);  arnorms  =  divide(arnormsReverse,  arnormsSorted);  int[]  idxInv  =  inverse(idxnorms);  RealMatrix  arnormsInv  =  selectColumns(arnorms,  idxInv);  double  negcovMax  =  (1.  -  negminresidualvariance)  /  square(arnormsInv).multiply(weights).getEntry(0,  0);  if  (negccov  >  negcovMax)  {  [BUGGY]  negccov  =(negccov  >  0)?  negcovMax  :  negminresidualvariance;  [BUGGY]  }  arzneg  =  times(arzneg,  repmat(arnormsInv,  dimension,  1));  RealMatrix  artmp  =  BD.multiply(arzneg);  RealMatrix  Cneg  =  artmp.multiply(diag(weights)).multiply(  artmp.transpose());  oldFac  +=  negalphaold  *  negccov;  C  =  C.scalarMultiply(oldFac)  .add(roneu)  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  updateCovariance  [RETURN_TYPE]  void  boolean  hsig  RealMatrix  bestArx  RealMatrix  arz  final  int[]  arindex  RealMatrix  xold  [VARIABLES]  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hasFiniteBounds  hasInfiniteBounds  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  init  inputSigma  lB  pcCol  sqrtDiagC  uB  RealMatrix  B  BD  C  Cneg  D  arnorms  arnormsInv  arnormsReverse  arnormsSorted  arpos  artmp  arx  arxk  arz  arzneg  bestArx  bestArz  diagC  diagD  insigma  pc  ps  roneu  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  max  mueff  negalphaold  negccov  negcovMax  negminresidualvariance  normps  oldFac  range  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  sumw  sumwq  value  valueRange  w  worstFitness  double[][]  boundaries  sigmaArray  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  int[]  arReverseIndex  arindex  idxInv  idxReverse  idxnorms  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.7071067811865475	751	751	1	replace	negccov  =(negccov  >  0)?  negcovMax  :  negminresidualvariance;	negccov  =  negcovMax;  	compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	7	1	replace
571	[BUG]  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness)  ==  0);  [CE]  ';'  expected  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness)  ==  0);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness)  ==  0);		non-compiled	[CE]  ';'  expected	4	None	add
572	[BUG]  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  worstFitness)  ==  0);  [CE]  ';'  expected  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  worstFitness)  ==  0);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    sigma  =  sigma  *  Math.min(historyWorst,  worstFitness)  ==  0);		non-compiled	[CE]  ';'  expected	4	None	add
573	[BUG]  [BUGGY]    sigma  =  sigma  *  Math.min(historyBest,  bestFitness)  ==  0);  [CE]  ';'  expected  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.min(historyBest,  bestFitness)  ==  0);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    sigma  =  sigma  *  Math.min(historyBest,  bestFitness)  ==  0);		non-compiled	[CE]  ';'  expected	4	None	add
574	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.exp(1.0  -  bestValue);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	    sigma  =  sigma  *  Math.exp(1.0  -  bestValue);		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	4	1
575	[BUG]  [BUGGY]    sigma  =  sigma  *  Math.exp(1.0  -  bestValue);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.exp(1.0  -  bestValue);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    sigma  =  sigma  *  Math.exp(1.0  -  bestValue);		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	4	1	add
575	[BUG]  [BUGGY]  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	add	    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness);		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	4	1
576	[BUG]  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness);  [FE]  AssertionError  testFitAccuracyDependsOnBoundary  [CONTEXT]  new  PointValuePair(bestArx.getColumn(0),  isMinimize  ?  bestFitness  :  -bestFitness);  if  (lastResult  !=  null  &&  getConvergenceChecker().converged(iterations,  current,  lastResult))  {  break  generationLoop;  }  lastResult  =  current;  }  if  (bestValue  ==  fitness[arindex[(int)(0.1+lambda/4.)]])  {  [BUGGY]    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness);  [BUGGY]  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  if  (iterations  >  2  &&  Math.max(historyWorst,  bestFitness)  -  Math.min(historyBest,  bestFitness)  ==  0)  {  sigma  =  sigma  *  Math.exp(0.2+cs/damps);  }  push(fitnessHistory,bestFitness);  fitfun.setValueRange(worstFitness-bestFitness);  if  (generateStatistics)  {  statisticsSigmaHistory.add(sigma);  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	1.0	482	482	1	replace	    sigma  =  sigma  *  Math.min(historyWorst,  bestFitness);		compilable	  [FE]  AssertionError  testFitAccuracyDependsOnBoundary	4	1	add
