bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  RealMatrix  lambda  =  randn2(dimension,  arz);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  lambda  =  randn2(dimension,  arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  lambda  =  randn2(dimension,  arz);	  RealMatrix    lambda    =    randn2(dimension,    lambda);    	non-compiled	[CE]  	23	None	replace
2	[BUG]  [BUGGY]  RealMatrix  arx  =  zeros(arz,  loambda);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  zeros(arz,  loambda);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  zeros(arz,  loambda);	  RealMatrix    arx    =    zeros(dimension,    loambda);    	non-compiled	[CE]  	21	None	replace
3	[BUG]  [BUGGY]  for(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  for(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	for(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }	  for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	16	None	replace
4	[BUG]  [BUGGY]  for(int  k  =  0;  k  <  checkFeasableCount;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  for(int  k  =  0;  k  <  checkFeasableCount;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	for(int  k  =  0;  k  <  checkFeasableCount;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }	  for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	16	None	replace
5	[BUG]  [BUGGY]  RealMatrix[]  arz  =  randn1(dimension,  lambda);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix[]  arz  =  randn1(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix[]  arz  =  randn1(dimension,  lambda);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	7	None	replace
6	[BUG]  [BUGGY]  RealMatrix[]  arz  =  randn2(dimension,  lambda);  [CE]  [FE]                  AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix[]  arz  =  randn2(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix[]  arz  =  randn2(dimension,  lambda);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	7	None	replace
7	[BUG]  [BUGGY]  double[]  lambda  =  arz.getBounds();  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  double[]  lambda  =  arz.getBounds();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	double[]  lambda  =  arz.getBounds();	  double[]    lambda    =    arz.getLambda();    	non-compiled	[CE]  	4	None	replace
8	[BUG]  [BUGGY]  For(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  For(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	For(int  k  =  0;  k  <  iterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }	  For(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	17	None	replace
9	[BUG]  [BUGGY]  RealMatrix  bestValue  =  zeros(dimension,  lambda);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  bestValue  =  zeros(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  bestValue  =  zeros(dimension,  lambda);	  if(arz    ==    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	24	None	replace
10	[BUG]  [BUGGY]  RealMatrix  arz  =  randn1(dimension,  lambda);  [CE]  [FE]                  AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arz  =  randn1(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arz  =  randn1(dimension,  lambda);	  if(arz    ==    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	24	None	replace
11	[BUG]  [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  generationLoop);  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  generationLoop);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn1(dimension,  lambda,  generationLoop);	  RealMatrix    arx    =    randn1(dimension,    lambda,    maxIterations);    	non-compiled	[CE]  	18	None	replace
12	[BUG]  [BUGGY]  RealMatrix  arx  =  randn2(dimension,  lambda,  maxIterations);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn2(dimension,  lambda,  maxIterations);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn2(dimension,  lambda,  maxIterations);	  RealMatrix    arx    =    randn1(dimension,    lambda,    maxIterations);    	non-compiled	[CE]  	18	None	replace
13	[BUG]  [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getFirstResult();  [CE]  [FE]                  AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getFirstResult();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	LatinIterator  <  PointValuePair>  lambda  =  getFirstResult();	  LatinIterator    <    PointValuePair>    lambda    =    getLastResult();    	non-compiled	[CE]  	13	None	replace
14	[BUG]  [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getLambda(0);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getLambda(0);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	LatinIterator  <  PointValuePair>  lambda  =  getLambda(0);	  LatinIterator    <    PointValuePair>    lambda    =    getLambda();    	non-compiled	[CE]  	26	None	replace
15	[BUG]  [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getLambda(arz);  [CE]  [FE]                  AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getLambda(arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	LatinIterator  <  PointValuePair>  lambda  =  getLambda(arz);	  LatinIterator    <    PointValuePair>    lambda    =    getLambda();    	non-compiled	[CE]  	26	None	replace
16	[BUG]  [BUGGY]  RealMatrix  lambda  =  randn1(arz,  lambda);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  lambda  =  randn1(arz,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  lambda  =  randn1(arz,  lambda);	  RealMatrix    lambda    =    randn1(dimension,    lambda);    	non-compiled	[CE]  	22	None	replace
17	[BUG]  [BUGGY]  RealMatrix  arx  =  zeros(arz,  lambda);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  zeros(arz,  lambda);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  zeros(arz,  lambda);	  RealMatrix    arx    =    zeros(arz,    dimension);    	non-compiled	[CE]  	11	None	replace
18	[BUG]  [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getFirstIterator();  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getFirstIterator();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	LatinIterator  <  PointValuePair>  lambda  =  getFirstIterator();	  LatinIterator    <    PointValuePair>    lambda    =    getLastIterator();    	non-compiled	[CE]  	1	None	replace
19	[BUG]  [BUGGY]  luate(arz,  0,  0,  0));  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  0,  0,  0));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  0,  0,  0));	  luate(arz,    dimension,    maxIterations,    arz));    	non-compiled	[CE]  	20	None	replace
20	[BUG]  [BUGGY]  luate(arz,  0,  0,  0,  0));  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  0,  0,  0,  0));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  0,  0,  0,  0));	  luate(arz,    dimension,    maxIterations,    arz));    	non-compiled	[CE]  	20	None	replace
21	[BUG]  [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  arz);  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  arz);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn1(dimension,  lambda,  arz);	  RealMatrix    arx    =    randn2(dimension,    lambda,    arz);    	non-compiled	[CE]  	28	None	replace
22	[BUG]  [BUGGY]  luate(arz,  0,  0,  k));  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  0,  0,  k));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  0,  0,  k));	  luate(arz,    dimension,    maxIterations,    k));    	non-compiled	[CE]  	19	None	replace
23	[BUG]  [BUGGY]  luate(arz,  scale,  maxIterations,  arz));  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  scale,  maxIterations,  arz));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  scale,  maxIterations,  arz));	  luate(arz,    dimension,    maxIterations,    k));    	non-compiled	[CE]  	19	None	replace
24	[BUG]  [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getEndPoint(),  arz);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  LatinIterator  <  PointValuePair>  lambda  =  getEndPoint(),  arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	LatinIterator  <  PointValuePair>  lambda  =  getEndPoint(),  arz);	  LatinIterator    <    PointValuePair>    lambda    =    getEndPoint();    	non-compiled	[CE]  	12	None	replace
25	[BUG]  [BUGGY]  (arz!=  null?  arz.getMaximumIterations()  :  0));  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  (arz!=  null?  arz.getMaximumIterations()  :  0));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	(arz!=  null?  arz.getMaximumIterations()  :  0));	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	9	None	replace
26	[BUG]  [BUGGY]  (arz!=  null?  arz.getMaximumSize()  :  0));  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  (arz!=  null?  arz.getMaximumSize()  :  0));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	(arz!=  null?  arz.getMaximumSize()  :  0));	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	9	None	replace
27	[BUG]  [BUGGY]  (arz!=  null?  bestValue  :  arz.scalarMultiply(sigma));  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  (arz!=  null?  bestValue  :  arz.scalarMultiply(sigma));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	(arz!=  null?  bestValue  :  arz.scalarMultiply(sigma));	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	10	None	replace
28	[BUG]  [BUGGY]  RealMatrix  arx  =  zeros(arz,  ambda);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  zeros(arz,  ambda);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  zeros(arz,  ambda);	  RealMatrix    arx    =    zeros(dimension,    ambda);    	non-compiled	[CE]  	30	None	replace
29	[BUG]  [BUGGY]  double[]  lambda  =  arz.getEndPoint().getLambda();  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  double[]  lambda  =  arz.getEndPoint().getLambda();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	double[]  lambda  =  arz.getEndPoint().getLambda();	  double[]    lambda    =    getEndPoint().getLambda();    	non-compiled	[CE]  	5	None	replace
30	[BUG]  [BUGGY]  double[]  lambda  =  arz.getRangeMatrix();  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  double[]  lambda  =  arz.getRangeMatrix();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	double[]  lambda  =  arz.getRangeMatrix();	  double[]    lambda    =    arz.getLambda();    	non-compiled	[CE]  	4	None	replace
31	[BUG]  [BUGGY]  RealMatrix  arx  =  randn2(dimension,  arz,  lambda);  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn2(dimension,  arz,  lambda);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn2(dimension,  arz,  lambda);	  RealMatrix    arx    =    randn2(dimension,    lambda,    lambda);    	non-compiled	[CE]  	8	None	replace
32	[BUG]  [BUGGY]  for(int  k  =  0;  k  <  lambda;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  for(int  k  =  0;  k  <  lambda;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	for(int  k  =  0;  k  <  lambda;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestValue);  }	  for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	16	None	replace
33	[BUG]  [BUGGY]  RealMatrix  arx  =  randn2(dimension,  lambda,  4);  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn2(dimension,  lambda,  4);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn2(dimension,  lambda,  4);	  RealMatrix    arx    =    randn2(dimension,    lambda,    arz);    	non-compiled	[CE]  	28	None	replace
34	[BUG]  [BUGGY]  double[]  lambda  =  getEndPoint().getLambda(arz);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  double[]  lambda  =  getEndPoint().getLambda(arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	double[]  lambda  =  getEndPoint().getLambda(arz);	  double[]    lambda    =    getEndPoint().getLambda();    	non-compiled	[CE]  	5	None	replace
35	[BUG]  [BUGGY]  RealMatrix  arz  =  randn2(dimension,  lambda);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arz  =  randn2(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arz  =  randn2(dimension,  lambda);	  if(arz    ==    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	24	None	replace
36	[BUG]  [BUGGY]  &&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint()  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  &&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint()  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	&&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint()	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestVal    	non-compiled	[CE]  	25	None	replace
37	[BUG]  [BUGGY]  &&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  &&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	&&  arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestVal    	non-compiled	[CE]  	25	None	replace
38	[BUG]  [BUGGY]  RealMatrix  bestValue  =  randn1(dimension,  lambda);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  bestValue  =  randn1(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  bestValue  =  randn1(dimension,  lambda);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	7	None	replace
39	[BUG]  [BUGGY]  Integer  sig  =  getGenericStatistics();  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Integer  sig  =  getGenericStatistics();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Integer  sig  =  getGenericStatistics();	  For(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	17	None	replace
40	[BUG]  [BUGGY]  Integer  sig  =  arz.getValue();  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Integer  sig  =  arz.getValue();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Integer  sig  =  arz.getValue();	  For(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	17	None	replace
41	[BUG]  [BUGGY]  .scalarMultiply(sigma));  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  .scalarMultiply(sigma));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	.scalarMultiply(sigma));	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	9	None	replace
42	[BUG]  [BUGGY]  .scalarMultiply(sigma);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  .scalarMultiply(sigma);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	.scalarMultiply(sigma);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	9	None	replace
43	[BUG]  [BUGGY]  RealMatrix  lambda  =  randn2(dimension,  lambda,  arz);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  lambda  =  randn2(dimension,  lambda,  arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  lambda  =  randn2(dimension,  lambda,  arz);	  RealMatrix    lambda    =    randn2(dimension,    lambda);    	non-compiled	[CE]  	23	None	replace
44	[BUG]  [BUGGY]  luate(arz,  0,  maxIterations,  arz));  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  0,  maxIterations,  arz));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  0,  maxIterations,  arz));	  luate(arz,    dimension,    maxIterations,    arz));    	non-compiled	[CE]  	20	None	replace
45	[BUG]  [BUGGY]  luate(arz,  generationLoop,  maxIterations,  arz));  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  generationLoop,  maxIterations,  arz));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  generationLoop,  maxIterations,  arz));	  luate(arz,    dimension,    maxIterations,    arz));    	non-compiled	[CE]  	20	None	replace
46	[BUG]  [BUGGY]  luate(arz,  0,  maxIterations,  k));  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  0,  maxIterations,  k));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  0,  maxIterations,  k));	  luate(arz,    dimension,    maxIterations,    k));    	non-compiled	[CE]  	19	None	replace
47	[BUG]  [BUGGY]  Magimizer.generateStatistics(arz));  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Magimizer.generateStatistics(arz));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Magimizer.generateStatistics(arz));	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	10	None	replace
48	[BUG]  [BUGGY]  Magimizer.generateStatistics(arz);  [CE]  [FE]                  AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Magimizer.generateStatistics(arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Magimizer.generateStatistics(arz);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	10	None	replace
49	[BUG]  [BUGGY]  double[]  lambda  =  arz.getMatrix();  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  double[]  lambda  =  arz.getMatrix();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	double[]  lambda  =  arz.getMatrix();	  double[]    lambda    =    arz.getLambda();    	non-compiled	[CE]  	4	None	replace
50	[BUG]  [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestVal  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestVal  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -bestVal	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestVal    	non-compiled	[CE]  	25	None	replace
51	[BUG]  [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -best  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -best  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -best	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestVal    	non-compiled	[CE]  	25	None	replace
52	[BUG]  [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  1);  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  randn1(dimension,  lambda,  1);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  randn1(dimension,  lambda,  1);	  RealMatrix    arx    =    randn1(dimension,    lambda,    maxIterations);    	non-compiled	[CE]  	18	None	replace
53	[BUG]  [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	10	None	replace
54	[BUG]  [BUGGY]  RealMatrix  arx  =  zeros(arz,  dimension  -  1);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  arx  =  zeros(arz,  dimension  -  1);  [BUGGY]      double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  arx  =  zeros(arz,  dimension  -  1);	  RealMatrix    arx    =    zeros(arz,    dimension);    	non-compiled	[CE]  	11	None	replace
55	[BUG]  [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	if(arz  ==  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(!isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  -	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -    	non-compiled	[CE]  	9	None	replace
56	[BUG]  [BUGGY]  luate(arz,  k,  maxIterations,  dimension));  [CE]  [FE]            AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  luate(arz,  k,  maxIterations,  dimension));  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	luate(arz,  k,  maxIterations,  dimension));	  luate(arz,    dimension,    maxIterations,    k));    	non-compiled	[CE]  	19	None	replace
57	[BUG]  [BUGGY]  if(arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  if(arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	if(arz!=  null)  {  for(int  k  =  0;  k  <  maxIterations;  k++)  {  if(isActiveCMA)  {  return  new  PointValuePair(getStartPoint(),  isMinimize?  bestValue  :	  if(arz    ==    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	29	None	replace
58	[BUG]  [BUGGY]  RealMatrix[]  lambda  =  randn1(dimension,  lambda);  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix[]  lambda  =  randn1(dimension,  lambda);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix[]  lambda  =  randn1(dimension,  lambda);	  if(arz!=    null)    {    for(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    	non-compiled	[CE]  	7	None	replace
59	[BUG]  [BUGGY]  RealMatrix  lambda  =  randn1(dimension,  lambda,  arz);  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  RealMatrix  lambda  =  randn1(dimension,  lambda,  arz);  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	RealMatrix  lambda  =  randn1(dimension,  lambda,  arz);	  RealMatrix    lambda    =    randn1(dimension,    lambda);    	non-compiled	[CE]  	22	None	replace
60	[BUG]  [BUGGY]  Integer[]  lambda  =  arz.getColumnMatrixes();  [CE]  [FE]              AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Integer[]  lambda  =  arz.getColumnMatrixes();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Integer[]  lambda  =  arz.getColumnMatrixes();	  For(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	17	None	replace
61	[BUG]  [BUGGY]  Integer  lambda  =  getLambda();  [CE]  [FE]                AssertionError      [CONTEXT]      PointValuePair  optimum  =  new  PointValuePair(getStartPoint(),  isMinimize  ?  bestValue  :  -bestValue);  PointValuePair  lastResult  =  null;    generationLoop:  for  (iterations  =  1;  iterations  <=  maxIterations;  iterations++)  {  RealMatrix  arz  =  randn1(dimension,  lambda);      [BUGGY]  Integer  lambda  =  getLambda();  [BUGGY]      RealMatrix  arx  =  zeros(dimension,  lambda);  double[]  fitness  =  new  double[lambda];  for  (int  k  =  0;  k  <  lambda;  k++)  {  RealMatrix  arxk  =  null;  for  (int  i  =  0;  i  <  checkFeasableCount+1;  i++)  {  if  (diagonalOnly  <=  0)  {  arxk  =  xmean.add(BD.multiply(arz.getColumnMatrix(k))  .scalarMultiply(sigma));  //  m  +  sig  *  Normal(0,C)  }  else  {  arxk  =  xmean.add(times(diagD,arz.getColumnMatrix(k))  [CLASS]  CMAESOptimizer  DoubleIndex  FitnessFunction  [METHOD]  doOptimize  [RETURN_TYPE]  PointValuePair  [VARIABLES]  TooManyEvaluationsException  e  boolean  DEFAULT_ISACTIVECMA  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sqrtDiagC  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  double  DEFAULT_STOPFITNESS  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  double[][]  boundaries  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  FitnessFunction  fitfun  int[]  arindex  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  PointValuePair  current  lastResult  optimum  	projects/Math18/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java	0.2672612419124244	377	377	1	replace	Integer  lambda  =  getLambda();	  For(int    k    =    0;    k    <    maxIterations;    k++)    {    if(!isActiveCMA)    {    return    new    PointValuePair(getStartPoint(),    isMinimize?    bestValue    :    -bestValue);    }    	non-compiled	[CE]  	17	None	replace
