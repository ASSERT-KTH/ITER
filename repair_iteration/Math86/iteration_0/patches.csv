bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number
this_action2	[BUG]  [BUGGY]  final  double[]  ltI  =  lTData[i]  -  1;  [CE]  bad  operand  types  for  binary  operator  '-'  [CONTEXT]  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }  for  (int  i  =  0;  i  <  order;  ++i)  {  [BUGGY]  final  double[]  ltI  =  lTData[i]  -  1;  [BUGGY]    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	134	134	2	replace	final  double[]  ltI  =  lTData[i]  -  1;	final  double[]  ltI  =  lTData[i];  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	5	None	replace
3	[BUG]  [BUGGY]  final  double[]  ltI  =  lTData[i]  +  1;  [CE]  bad  operand  types  for  binary  operator  '+'  [CONTEXT]  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }  for  (int  i  =  0;  i  <  order;  ++i)  {  [BUGGY]  final  double[]  ltI  =  lTData[i]  +  1;  [BUGGY]    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	134	134	2	replace	final  double[]  ltI  =  lTData[i]  +  1;	final  double[]  ltI  =  lTData[i];  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '+'	5	None	replace
4	[BUG]  [BUGGY]  final  double[]  ltI  =  lTData[i]  /  lJ;  [CE]  cannot  find  symbol  lJ  [CONTEXT]  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }  for  (int  i  =  0;  i  <  order;  ++i)  {  [BUGGY]  final  double[]  ltI  =  lTData[i]  /  lJ;  [BUGGY]    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	134	134	2	replace	final  double[]  ltI  =  lTData[i]  /  lJ;	final  double[]  ltI  =  lTData[i];  	non-compiled	[CE]  cannot  find  symbol  lJ	5	None	replace
5	[BUG]  [BUGGY]    [CE]  cannot  find  symbol  ltI  [CONTEXT]  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }  for  (int  i  =  0;  i  <  order;  ++i)  {  [BUGGY]    [BUGGY]    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	134	134	2	replace	  	final  double[]  ltI  =  lTData[i];  	non-compiled	[CE]  cannot  find  symbol  ltI	5	None	replace
12	[BUG]  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  =  lTData[i];  ltI[i]  =  Math.sqrt(ltI[i]);  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  =  lTData[i];  ltI[i]  =  Math.sqrt(ltI[i]);  }  [BUGGY]  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	139	139	2	replace	    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  =  lTData[i];  ltI[i]  =  Math.sqrt(ltI[i]);  }		non-compiled	[CE]  illegal  start  of  expression	10	None	add
13	[BUG]  [BUGGY]    final  double[][]  order  =  Math.sqrt(ltI[i]);  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  }  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  [BUGGY]    final  double[][]  order  =  Math.sqrt(ltI[i]);  [BUGGY]  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	139	139	2	replace	    final  double[][]  order  =  Math.sqrt(ltI[i]);		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	10	None	add
14	[BUG]  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  lTData[i]  =  Math.sqrt(ltI[i]);  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  lTData[i]  =  Math.sqrt(ltI[i]);  }  [BUGGY]  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	139	139	2	replace	    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  lTData[i]  =  Math.sqrt(ltI[i]);  }		non-compiled	[CE]  illegal  start  of  expression	10	None	add
15	[BUG]  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  ltData[i]  =  Math.sqrt(ltI[i]);  }  [CE]  illegal  start  of  expression  [CONTEXT]  }  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  [BUGGY]    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  ltData[i]  =  Math.sqrt(ltI[i]);  }  [BUGGY]  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	139	139	2	replace	    if(order  >  1)  {  for(int  i  =  0;  i  <  order;  ++i)  {  ltI[i]  *  ltData[i]  =  Math.sqrt(ltI[i]);  }		non-compiled	[CE]  illegal  start  of  expression	10	None	add
22	[BUG]  [BUGGY]  ltQ[p]  -=  ltI[q]  *  ltData[p];  [CE]  cannot  find  symbol  ltData  [CONTEXT]    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  [BUGGY]  ltQ[p]  -=  ltI[q]  *  ltData[p];  [BUGGY]  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	145	145	2	replace	ltQ[p]  -=  ltI[q]  *  ltData[p];	ltQ[p]  -=  ltI[q]  *  ltI[p];  	non-compiled	[CE]  cannot  find  symbol  ltData	19	None	replace
33	[BUG]  [BUGGY]  ltI[q]  *=(inverse  >  0)?  ltI[q],  inverse  :  inverse;  [CE]  :  expected  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]  ltI[q]  *=(inverse  >  0)?  ltI[q],  inverse  :  inverse;  [BUGGY]  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	replace	ltI[q]  *=(inverse  >  0)?  ltI[q],  inverse  :  inverse;	ltI[q]  *=  inverse;  	non-compiled	[CE]  :  expected	13	None	replace
34	[BUG]  [BUGGY]  ltI[q]  *=(inverse  >  0)?  ltI[q].inverse  :  inverse;  [CE]  double  cannot  be  dereferenced  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]  ltI[q]  *=(inverse  >  0)?  ltI[q].inverse  :  inverse;  [BUGGY]  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	replace	ltI[q]  *=(inverse  >  0)?  ltI[q].inverse  :  inverse;	ltI[q]  *=  inverse;  	non-compiled	[CE]  double  cannot  be  dereferenced	13	None	replace
41	[BUG]  [BUGGY]    double  order  =  Math.sqrt(relativeSymmetryThreshold);  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]    double  order  =  Math.sqrt(relativeSymmetryThreshold);  [BUGGY]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	    double  order  =  Math.sqrt(relativeSymmetryThreshold);		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	4	None	add
42	[BUG]  [BUGGY]    int  order  =  Math.max(relativeSymmetryThreshold);  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]    int  order  =  Math.max(relativeSymmetryThreshold);  [BUGGY]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	    int  order  =  Math.max(relativeSymmetryThreshold);		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	4	None	add
43	[BUG]  [BUGGY]    int  order  =  Math.order(lTData,  maxDelta);  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]    int  order  =  Math.order(lTData,  maxDelta);  [BUGGY]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	    int  order  =  Math.order(lTData,  maxDelta);		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	4	None	add
44	[BUG]  [BUGGY]    double  order  =  Math.max(relativeSymmetryThreshold);  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]    double  order  =  Math.max(relativeSymmetryThreshold);  [BUGGY]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	    double  order  =  Math.max(relativeSymmetryThreshold);		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	4	None	add
45	[BUG]  [BUGGY]    double  order  =  Math.max(relativeSymmetryThreshold,  Math.abs(lIJ));  [CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]    double  order  =  Math.max(relativeSymmetryThreshold,  Math.abs(lIJ));  [BUGGY]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	    double  order  =  Math.max(relativeSymmetryThreshold,  Math.abs(lIJ));		non-compiled	[CE]  variable  order  is  already  defined  in  constructor  CholeskyDecompositionImpl(RealMatrix,double,double)	4	None	add
52	[BUG]  [BUGGY]    ltI[q]  =  Math.sqrt(ltI[q],  inverse);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]    ltI[q]  =  Math.sqrt(ltI[q],  inverse);  [BUGGY]  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	replace	    ltI[q]  =  Math.sqrt(ltI[q],  inverse);		non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	14	None	add
53	[BUG]  [BUGGY]  [FE]  AssertionError  testMath274  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]    ltI[q]  =  Math.rint(ltI[q]);  [BUGGY]  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	add	    ltI[q]  =  Math.rint(ltI[q]);		compilable	  [FE]  AssertionError  testMath274	14	2
54	[BUG]  [BUGGY]    ltI[q]  =  Math.rint(ltI[q]);  [FE]  AssertionError  testMath274  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]    ltI[q]  =  Math.rint(ltI[q]);  [BUGGY]  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	replace	    ltI[q]  =  Math.rint(ltI[q]);		compilable	  [FE]  AssertionError  testMath274	14	2	add
54	[BUG]  [BUGGY]  [FE]  AssertionError  testMath274  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]    ltI[q]  =  Math.abs(ltI[q]);  [BUGGY]  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	add	    ltI[q]  =  Math.abs(ltI[q]);		compilable	  [FE]  AssertionError  testMath274	14	2
55	[BUG]  [BUGGY]    ltI[q]  =  Math.abs(ltI[q]);  [FE]  AssertionError  testMath274  [CONTEXT]  for  (int  i  =  0;  i  <  order;  ++i)  {  final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  [BUGGY]    ltI[q]  =  Math.abs(ltI[q]);  [BUGGY]  ltI[q]  *=  inverse;  final  double[]  ltQ  =  lTData[q];  for  (int  p  =  q;  p  <  order;  ++p)  {  ltQ[p]  -=  ltI[q]  *  ltI[p];  }  }  }  }  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	142	142	2	replace	    ltI[q]  =  Math.abs(ltI[q]);		compilable	  [FE]  AssertionError  testMath274	14	2	add
62	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  absoluteSymmetryThreshold;  ++i)  {  [CE]  cannot  find  symbol  absoluteSymmetryThreshold  [CONTEXT]  final  double  maxDelta  =  relativeSymmetryThreshold  *  Math.max(Math.abs(lIJ),  Math.abs(lJI));  if  (Math.abs(lIJ  -  lJI)  >  maxDelta)  {  throw  new  NotSymmetricMatrixException();  }  lJ[i]  =  0;  }  }    [BUGGY]  for(int  i  =  0;  i  <  absoluteSymmetryThreshold;  ++i)  {  [BUGGY]    final  double[]  ltI  =  lTData[i];    ltI[i]  =  Math.sqrt(ltI[i]);  final  double  inverse  =  1.0  /  ltI[i];  for  (int  q  =  order  -  1;  q  >  i;  --q)  {  ltI[q]  *=  inverse;  [CLASS]  CholeskyDecompositionImpl  Solver  [METHOD]  <init>  [RETURN_TYPE]  RealMatrix,double,double)  RealMatrix  matrix  final  double  relativeSymmetryThreshold  final  double  absolutePositivityThreshold  [VARIABLES]  double[][]  lTData  boolean  RealMatrix  cachedL  cachedLT  matrix  double[]  lI  lJ  ltI  ltQ  double  DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD  DEFAULT_RELATIVE_SYMMETRY_THRESHOLD  absolutePositivityThreshold  inverse  lIJ  lJI  maxDelta  relativeSymmetryThreshold  int  i  j  order  p  q  	projects/Math86/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	0.5345224838248488	132	132	2	replace	for(int  i  =  0;  i  <  absoluteSymmetryThreshold;  ++i)  {	for  (int  i  =  0;  i  <  order;  ++i)  {  	non-compiled	[CE]  cannot  find  symbol  absoluteSymmetryThreshold	3	None	replace
